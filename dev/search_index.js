var documenterSearchIndex = {"docs":
[{"location":"specs/Spec_Neighbors/#Spec:-Module-Verlet.Neighbors","page":"Neighbors","title":"Spec: Module Verlet.Neighbors","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"Purpose: Efficient neighbor list construction and orchestration for force evaluation.","category":"page"},{"location":"specs/Spec_Neighbors/#Types","page":"Neighbors","title":"Types","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"struct NeighborPair{F<:AbstractPotentialPair, IntT<:Integer}\ni::IntT, j::IntT, pair::F (per-pair parameters).\nconst PotentialNeighborList{F} = StructArray{NeighborPair{F,T_Int}} where {F<:AbstractPotentialPair}\nPer-potential neighbor container (StructArray-backed for SoA layout).\nmutable struct MasterNeighborList{D,T}\nTracks cutoff, skin, and a pairs::Vector{SVector{2,Int}} holding unique (i<j) candidates within cutoff + skin using minimum-image distances.\nStores reference positions (r0), displacement bounds, the active cell grid shape ncells, and reusable head/next buffers for the cell build.\nConstructors: MasterNeighborList(sys; cutoff, skin) or MasterNeighborList(positions, box; cutoff, skin).\nHelper: brute_force_pairs(sys_or_positions, box_or_cutoff, cutoff) returns the set of (i,j) pairs within the provided cutoff using an O(N^2) sweep (useful for validation).","category":"page"},{"location":"specs/Spec_Neighbors/#Building-neighbors","page":"Neighbors","title":"Building neighbors","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"build_master_neighborlist!(master, positions_or_sys, box_or_kwargs; r_verlet, method=:cells)\nPurpose: Refresh master.pairs with unique (i<j) candidates consistent with the requested Verlet radius r_verlet.\nmaster.cutoff is updated to max(0, r_verlet - master.skin) and master.r0 holds the reference positions used for future displacement checks.\nMethods:\n:cells (default): cell-list algorithm using the internal ncells, head, and next buffers, expected O(N).\n:bruteforce: O(N^2) sweep that applies the cutoff directly; helpful for validation.\n:all_pairs: fills every (i<j) pair ignoring the cutoff (testing / debugging).\nrebuild!(master, sys_or_positions, box; method=:cells, cutoff=master.cutoff)\nLower-level entry point called by build_master_neighborlist!; accepts either a System or raw positions plus box.\nbuild_cellgrid(...), rebin!(...)\nbuild_cellgrid(...), rebin!(...)\nUtilities for the cell-list implementation (internal surface area; caller rarely uses directly).","category":"page"},{"location":"specs/Spec_Neighbors/#ForceField-integration","page":"Neighbors","title":"ForceField integration","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"build_neighbors_from_master!(pot::AbstractPairPotential, sys::System, master::MasterNeighborList)\nPopulates pot.neighborlist using master.pairs and per-type pair parameters.\nComputes the current squared distance on the fly (minimum-image) and includes (i,j) when not excluded and r2 < (p.rc + pot.skin)^2.\nbuild_all_neighbors!(master, ff::ForceField, sys::System; method=:cells)\nComputes a master list with r_verlet = maximum(max(p.rc) + pot.skin for pot in ff.layers) (over all layer parameter tables), then builds per-layer lists.","category":"page"},{"location":"specs/Spec_Neighbors/#Exclusions","page":"Neighbors","title":"Exclusions","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"is_excluded(pot::AbstractPairPotential, i, j)\nBasic tuple membership check on pot.exclusions (callers can precompute or specialize for performance).","category":"page"},{"location":"specs/Spec_Neighbors/#Invariants","page":"Neighbors","title":"Invariants","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"master.pairs contains unique (i<j) pairs; no self-pairs; the stored cutoff equals the requested Verlet radius minus skin.\nPer-potential neighbor lists are empty!+push!-rebuilt; capacity may be retained.","category":"page"},{"location":"specs/Spec_Neighbors/#Performance","page":"Neighbors","title":"Performance","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"Cell-list path is expected O(N) with good binning; bruteforce is O(N^2).\nStructArray neighbors enable tight loops in potentials (good cache behavior).","category":"page"},{"location":"specs/Spec_Neighbors/#Example","page":"Neighbors","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"using Verlet, StaticArrays\nbox = CubicBox(10.0)\nR = [@SVector randn(3) for _ in 1:128]; wrap_positions!(R, box)\nsys = System(R, fill(@SVector zeros(3), 128), fill(@SVector zeros(3), 128), ones(128), box, ones(Int,128), Dict(1=>:A))\n\nlj = begin\n  params = PairTable(fill(LJPair(1.0, 1.0, 2.5), (1,1)))\n  Verlet.Potentials.LennardJones(params, Tuple{Int,Int}[], 0.5)\nend\nff = ForceField((lj,))\nmaster = MasterNeighborList(sys; cutoff=2.5, skin=0.5)\nbuild_all_neighbors!(master, ff, sys; method=:cells)","category":"page"},{"location":"specs/Spec_Neighbors/#Cell-Grid-Details","page":"Neighbors","title":"Cell Grid Details","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"CellGrid{D,IT,T} fields:\nL::T: cubic box length; assumed consistent with positions’ units.\ncell_size::T: effective uniform cell width actually used for binning.\ndims::NTuple{D,IT}: number of cells along each axis (each ≥ 1).\nheads::Vector{IT}: length prod(dims); head index per cell (0 sentinel = empty).\nnext::Vector{IT}: length N; intrusive linked-list “next” pointer per particle (0 = end).\nBuild and rebin:\nbuild_cellgrid(R, box; cell_size) constructs a grid sized so that the effective width cs_eff = L / floor(L/cell_size) ≥ cell_size and immediately rebin!s the positions.\nrebin!(grid, R, box) resets heads and next and push-fronts each particle index i into its cell list using periodic mapping.\nIndexing and periodicity:\nPositions are mapped to [0, L) via x0 = x + 0.5L; x0 -= floor(x0 / L) * L, then to cell indices 1..n via floor(x0/cell_size)+1 clamped to [1,n].\nCell linear index computed via row-major strides over dims.\nA 3^D-neighbor stencil around each base cell is enumerated; offsets use periodic wrap per axis.","category":"page"},{"location":"specs/Spec_Neighbors/#Master-List-Algorithm","page":"Neighbors","title":"Master List Algorithm","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":":cells (default):\n_choose_cell_grid selects a uniform dims tuple so that each cell edge is at most cutoff + skin.\nParticles are assigned to cells by fractional coordinates and stored in intrusive lists via the head/next buffers.\nFor each base cell, the algorithm visits the 3^D neighbor stencil with wraparound and emits (i, j) with i < j whenever the minimum-image squared distance is ≤ (cutoff + skin)^2.\nncells, head, and next are kept on the list object and reused between builds; buffers resize only when the particle count or grid shape changes.\n:bruteforce: nested loops for i<j, computing minimum-image distances directly and respecting the same cutoff radius (expected O(N^2)).\n:all_pairs: nested loops for i<j that bypass the cutoff entirely; useful for debugging and consistency tests.","category":"page"},{"location":"specs/Spec_Neighbors/#Sorting-and-Uniqueness","page":"Neighbors","title":"Sorting and Uniqueness","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"All methods generate unique (i<j) pairs by construction; no post-processing sort!/unique! is performed.","category":"page"},{"location":"specs/Spec_Neighbors/#Assumptions-and-Invariants","page":"Neighbors","title":"Assumptions and Invariants","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"Positions are SVector{D,T} for arbitrary D ≥ 1 (default D=3).\nMinimum-image distances under the provided CubicBox determine pair inclusion.\nmaster.pairs is cleared before each rebuild; buffers grow amortized.","category":"page"},{"location":"numerics/#Numerical-Notes","page":"Numerical Notes","title":"Numerical Notes","text":"","category":"section"},{"location":"numerics/#Constraint-Tolerances-and-Thermostat-Parameters","page":"Numerical Notes","title":"Constraint Tolerances and Thermostat Parameters","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"When using langevin_baoab_constrained!, the SHAKE and RATTLE solvers enforce distance constraints up to the tolerance specified in DistanceConstraints.","category":"page"},{"location":"numerics/#Interplay-with-γ-and-T","page":"Numerical Notes","title":"Interplay with γ and T","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Larger friction γ and higher temperature T produce stronger stochastic kicks in the OU step.\nThis may increase the number of iterations needed for constraint convergence.\nIf the solver fails to converge within maxiter, consider relaxing tol slightly.","category":"page"},{"location":"numerics/#Mass-Variance","page":"Numerical Notes","title":"Mass Variance","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Constraints involving very light particles (e.g. hydrogens) can converge more slowly if highly coupled with heavier atoms. This is expected and usually acceptable for simple bond constraints.","category":"page"},{"location":"numerics/#Degrees-of-Freedom-and-Temperature","page":"Numerical Notes","title":"Degrees of Freedom and Temperature","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"The function instantaneous_temperature uses the full degrees of freedom by default. For constrained systems, users who want diagnostics consistent with statistical mechanics should instead call:","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"degrees_of_freedom(sys; constraints=cons, remove_com=false)","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"and use this value in temperature calculations.","category":"page"},{"location":"numerics/#Reproducibility","page":"Numerical Notes","title":"Reproducibility","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"The stochastic step uses the provided RNG. Set a fixed seed (e.g. rng = MersenneTwister(1234)) in tests or benchmarks for reproducibility.","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"See also: constraint_residuals for monitoring how well constraints are satisfied.","category":"page"},{"location":"specs/Spec_Module_Index/#Spec-Index","page":"Overview","title":"Spec Index","text":"","category":"section"},{"location":"specs/Spec_Module_Index/","page":"Overview","title":"Overview","text":"Top-level: Verlet\nCore: Verlet.Core\nNeighbors: Verlet.Neighbors\nIntegrators: Verlet.Integrators\nPotentials: Verlet.Potentials\nConstraints: Verlet.Constraints\nThermostats: Verlet.Thermostats\nElectrostatics: Verlet.Electrostatics","category":"page"},{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [\n    Verlet.Core,\n    Verlet.Neighbors,\n    Verlet.Potentials,\n    Verlet.Constraints,\n    Verlet.Thermostats\n]\nOrder = [:function, :type]","category":"page"},{"location":"api/#Verlet.Core.AbstractBox","page":"API","title":"Verlet.Core.AbstractBox","text":"abstract type AbstractBox{T<:AbstractFloat} end\n\nAbstract type for simulation boxes.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Core.AbstractIntegrator","page":"API","title":"Verlet.Core.AbstractIntegrator","text":"abstract type AbstractIntegrator end\n\nMarker supertype for all integration / minimisation schemes.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Core.CubicBox","page":"API","title":"Verlet.Core.CubicBox","text":"struct CubicBox{T<:AbstractFloat} <: AbstractBox{T}\n\nSimple cubic periodic box with side length L.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Core.System","page":"API","title":"Verlet.Core.System","text":"System(T<:AbstractFloat, IT<:Integer, Dims)\n\nA flexible and type-stable container for particle-based simulations.\n\nType Parameters\n\nT<:AbstractFloat: Floating-point type for particle properties (e.g., Float32, Float64).\nIT<:Integer: Integer type for particle indices and types (e.g., Int32, Int64).\nDims: The number of spatial dimensions.\n\nFields\n\npositions::Vector{SVector{Dims, T}}: Particle positions.\nvelocities::Vector{SVector{Dims, T}}: Particle velocities.\nforces::Vector{SVector{Dims, T}}: Forces acting on particles.\nmasses::Vector{T}: Particle masses.\nbox::AbstractBox{T}: Simulation box defining the periodic boundary conditions.\ntypes::Vector{IT}: Particle type identifiers (integers).\ntype_names::Dict{IT, Symbol}: Mapping from type identifiers to descriptive names (e.g., 1 => :H).\nnatoms::IT: Total number of atoms.\nspecific_potentials::Tuple: Optional bonded interactions.\nforcefield: Object providing compute_forces!; typically a ForceField or nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Core.integrate!-Tuple{AbstractIntegrator, System, Integer, Vararg{Any}}","page":"API","title":"Verlet.Core.integrate!","text":"integrate!(integrator::AbstractIntegrator, system::System, nsteps::Integer, args...; kwargs...) -> System\n\nRun integrator against system for nsteps iterations. Concrete integrators must implement this method; the default definition throws.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.kinetic_energy-Union{Tuple{System{T, IT, Dims, BOX} where BOX<:AbstractBox{T}}, Tuple{Dims}, Tuple{IT}, Tuple{T}} where {T, IT, Dims}","page":"API","title":"Verlet.Core.kinetic_energy","text":"kinetic_energy(sys::System) -> T\n\nTotal kinetic energy: ∑ ½ mᵢ ‖vᵢ‖².\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.natoms-Tuple{System}","page":"API","title":"Verlet.Core.natoms","text":"natoms(sys::System) -> Integer\n\nGet the number of atoms in the system.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.natomtypes-Tuple{System}","page":"API","title":"Verlet.Core.natomtypes","text":"natomtypes(sys::System) -> Int\n\nGet the number of unique atom types in the system.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.potential_energy-Union{Tuple{D}, Tuple{IT}, Tuple{T}, Tuple{System{T, IT, D, BOX} where BOX<:AbstractBox{T}, Function}} where {T, IT, D}","page":"API","title":"Verlet.Core.potential_energy","text":"potential_energy(system::System{T}, forces::Function) -> T\n\nObtain the potential energy by calling forces(system.positions; return_potential=true). If the force function does not support this protocol, the helper will raise an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.wrap_positions!-Union{Tuple{T}, Tuple{D}, Tuple{Array{StaticArraysCore.SVector{D, T}, 1}, CubicBox{T}}} where {D, T<:AbstractFloat}","page":"API","title":"Verlet.Core.wrap_positions!","text":"wrap_positions!(R, box::CubicBox)\n\nWrap particle positions R into the primary periodic image of box in-place. This is useful before building neighbor lists or measuring displacements.\n\nThe resulting positions will be in the range (-L/2, L/2].\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.CellGrid","page":"API","title":"Verlet.Neighbors.CellGrid","text":"CellGrid{D,IT<:Integer,T<:Real}\n\nLinked-list cell grid for cubic periodic boxes. The domain is split into a uniform dims grid of cubic cells with an intrusive linked list (heads, next) storing particle indices in each cell. This enables O(N) rebinning at fixed density and powers the O(N) neighbor build.\n\nFields\n\nL::T: cubic box length.\ncell_size::T: effective uniform cell width used for binning.\ndims::NTuple{D,IT}: number of cells along each axis (each ≥ 1).\nheads::Vector{IT}: length prod(dims); head index per cell (0 sentinel).\nnext::Vector{IT}: length N; linked list “next” pointer per particle (0).\n\ntip: How `cell_size` is chosen\nbuild_cellgrid computes n = floor(Int, L/cell_size) and then uses the effective width L/n for indexing so that a (3ᵈ) stencil is sufficient for a search radius ≤ cell_size.\n\nwarning: Units\nR and L must be expressed in the same length units.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Neighbors.MasterNeighborList","page":"API","title":"Verlet.Neighbors.MasterNeighborList","text":"MasterNeighborList{D,T}\n\nMaster Verlet neighbor list storing unique (i, j) candidates within cutoff + skin for a D-dimensional periodic system. The list retains buffers used by the cell-linked builder so repeated rebuilds avoid allocations.\n\nCreate instances via MasterNeighborList(sys; cutoff, skin) or MasterNeighborList(positions, box; cutoff, skin).\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Neighbors.build_cellgrid-Tuple{AbstractVector, Any}","page":"API","title":"Verlet.Neighbors.build_cellgrid","text":"build_cellgrid(R, box; cell_size)\n\nCreate a new CellGrid sized for cell_size and bin positions R (N×D). Returns a populated grid with linked lists set for particle indices 1..N.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.build_master_neighborlist!-Union{Tuple{T}, Tuple{D}, Tuple{MasterNeighborList{D, T}, System}} where {D, T}","page":"API","title":"Verlet.Neighbors.build_master_neighborlist!","text":"build_master_neighborlist!(nl::MasterNeighborList, sys::System; r_verlet, method=:cells)\nbuild_master_neighborlist!(nl::MasterNeighborList, positions, box; r_verlet, method=:cells)\n\nUpdate a MasterNeighborList in-place so that it contains all candidate (i, j) pairs consistent with the requested Verlet radius r_verlet.\n\nmethod chooses the builder:\n\n:cells (default) uses the cell-linked list sweep and is O(N) for large systems.\n:bruteforce walks all i<j pairs (O(N^2)), useful for debugging and validation.\n:all_pairs stores every (i, j) combination regardless of the cutoff.\n\nThe list's cutoff is updated to max(zero(typeof(nl.cutoff)), r_verlet - nl.skin) so that the stored pairs are within cutoff + skin. Returns nl.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.rebin!-Union{Tuple{T}, Tuple{IT}, Tuple{D}, Tuple{Verlet.Neighbors.CellGrid{D, IT, T}, AbstractVector, Any}} where {D, IT<:Integer, T<:Real}","page":"API","title":"Verlet.Neighbors.rebin!","text":"rebin!(grid, R, box) -> grid\n\nReset the grid's heads and next and bin the positions R into cells according to the current cell_size and periodic cubic box box.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Potentials.CoulPair","page":"API","title":"Verlet.Potentials.CoulPair","text":"CoulPair{T<:Number}\n\nParameters for a Coulomb interaction between two particle types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Potentials.LJPair","page":"API","title":"Verlet.Potentials.LJPair","text":"LJPair{T<:Number}\n\nParameters for a Lennard-Jones interaction between two particle types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Potentials.PairTable","page":"API","title":"Verlet.Potentials.PairTable","text":"PairTable{F<:AbstractPotentialPair}\n\nA table to store parameters for each pair of particle types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Constraints.DistanceConstraints","page":"API","title":"Verlet.Constraints.DistanceConstraints","text":"struct DistanceConstraints{T_Int,T_Float}\n\nImmutable set of pairwise distance constraints for SHAKE/RATTLE.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Constraints.apply_rattle!-Tuple{System, DistanceConstraints}","page":"API","title":"Verlet.Constraints.apply_rattle!","text":"apply_rattle!(sys, cons)\n\nCorrect velocities to satisfy velocity constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.apply_shake!-Tuple{System, DistanceConstraints, Any}","page":"API","title":"Verlet.Constraints.apply_shake!","text":"apply_shake!(sys, cons, dt)\n\nIteratively correct positions to satisfy constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.constraint_residuals-Tuple{System, DistanceConstraints}","page":"API","title":"Verlet.Constraints.constraint_residuals","text":"constraint_residuals(sys::System, cons::DistanceConstraints) -> (; maxC, rmsC, maxCd, rmsCd)\n\nCompute the constraint residuals for a system subject to pairwise distance constraints.\n\nFor each constraint l with atoms (i, j) and target distance r0_l:\n\nPosition residual: C_l = ||r_i - r_j||^2 - r0_l^2\nVelocity residual: Ċ_l = 2 (r_i - r_j) ⋅ (v_i - v_j)\n\nReturns a named tuple with maxC, rmsC, maxCd, rmsCd.\n\nExample\n\nsys = System(\n    [SVector(0.0, 0, 0), SVector(1.0, 0, 0)],\n    [SVector(0.0, 0, 0), SVector(0.0, 0, 0)],\n    [SVector(0.0, 0, 0), SVector(0.0, 0, 0)],\n    [1.0, 1.0],\n    CubicBox(10.0),\n    [1, 1],\n    Dict(1 => :A)\n)\ncons = DistanceConstraints([(1,2)], [1.0])\nconstraint_residuals(sys, cons)\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.remove_com_motion!-Tuple{System}","page":"API","title":"Verlet.Constraints.remove_com_motion!","text":"remove_com_motion!(sys; which=:velocity)\n\nRemove center-of-mass motion from velocities/positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.velocity_verlet_shake_rattle!-Tuple{System, Any, Any, DistanceConstraints}","page":"API","title":"Verlet.Constraints.velocity_verlet_shake_rattle!","text":"velocity_verlet_shake_rattle!(sys, forces, dt, cons)\n\nConstrained velocity Verlet step with SHAKE/RATTLE.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.degrees_of_freedom-Tuple{System}","page":"API","title":"Verlet.Thermostats.degrees_of_freedom","text":"degrees_of_freedom(sys; constraints=nothing, remove_com=false) -> Int\n\nEffective translational DoF, reduced by number of constraints and optionally COM removal. This is the canonical method. A no-keyword fallback is provided for backward compatibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.instantaneous_temperature-Union{Tuple{System{T, IT, Dims, BOX} where BOX<:AbstractBox{T}}, Tuple{Dims}, Tuple{IT}, Tuple{T}} where {T, IT, Dims}","page":"API","title":"Verlet.Thermostats.instantaneous_temperature","text":"instantaneous_temperature(sys; kB=1.0) -> Float64\n\nCompute instantaneous temperature via equipartition: T = 2 * KE / (kB * dof).\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.langevin_baoab!-Union{Tuple{Dims}, Tuple{IT}, Tuple{T}, Tuple{System{T, IT, Dims, BOX} where BOX<:AbstractBox{T}, Any, Any}} where {T, IT, Dims}","page":"API","title":"Verlet.Thermostats.langevin_baoab!","text":"langevin_baoab!(sys, forces, dt; γ, T, kB=1.0, rng=Random.default_rng())\n\nAdvance one step with the Langevin BAOAB integrator: B(half) → A(half) → O(OU) → A(half) → B(half). With γ=0, this reduces to velocity-Verlet (deterministic).\n\nArguments\n\nsys     : particle system\nforces : callable F = forces(positions)\ndt     : time step\n\nKeywords\n\nγ  : friction (1/time)\nT  : target temperature\nkB : Boltzmann constant (default 1.0)\nrng: AbstractRNG for reproducibility\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.langevin_baoab_constrained!-Union{Tuple{Dims}, Tuple{IT}, Tuple{T}, Tuple{System{T, IT, Dims, BOX} where BOX<:AbstractBox{T}, Any, Any, DistanceConstraints}} where {T, IT, Dims}","page":"API","title":"Verlet.Thermostats.langevin_baoab_constrained!","text":"langevin_baoab_constrained!(sys::System, forces, dt, cons::DistanceConstraints;\n                            γ, T, kB=1.0, rng=Random.default_rng())\n\nAdvance one constrained NVT BAOAB step with SHAKE/RATTLE projections.\n\nSplitting and projections:\n\nB (half kick)         → apply_rattle! (velocities)\nA (half drift)        → apply_shake! (positions)\nO (OU stochastic)     → apply_rattle! (velocities)\nA (half drift)        → apply_shake! (positions)\nRecompute forces\nB (half kick)         → apply_rattle! (velocities)\n\nNotes:\n\nUses exp(-γ*dt) for the OU decay. Noise variance is (1 - c^2) * kB*T / m_i per component.\nWith constraints, prefer this method over the unconstrained langevin_baoab!.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.velocity_rescale!-Tuple{System, Real}","page":"API","title":"Verlet.Thermostats.velocity_rescale!","text":"velocity_rescale!(sys, T; kB=1.0)\n\nDeterministically rescale velocities to match target temperature T.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Molecular systems often contain rigid bonds or fixed distances between atoms. These are represented using the DistanceConstraints type and enforced using SHAKE (positions) and RATTLE (velocities).","category":"page"},{"location":"constraints/#Residual-Monitoring","page":"Constraints","title":"Residual Monitoring","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The helper function constraint_residuals reports how well constraints are satisfied at a given state:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"maxC, rmsC — maximum and RMS positional residuals\nmaxCd, rmsCd — maximum and RMS velocity residuals","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"using Verlet, StaticArrays\npositions = [SVector{3}(0.0, 0.0, 0.0), SVector{3}(1.0, 0.0, 0.0)]\nvelocities = [SVector{3}(0.0, 0.0, 0.0) for _ in 1:2]\nforces = [SVector{3}(0.0, 0.0, 0.0) for _ in 1:2]\nmasses = ones(2)\nbox = CubicBox(10.0)\ntypes = [1, 1]\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names)\ncons = DistanceConstraints([(1,2)], [1.0])\nconstraint_residuals(sys, cons)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"These values are useful for debugging and regression testing.","category":"page"},{"location":"constraints/#Usage-with-cBAOAB","page":"Constraints","title":"Usage with cBAOAB","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"When running constrained Langevin dynamics with langevin_baoab_constrained!, residuals should remain close to machine precision (typically 1e-8 or smaller) if the solver tolerance is sufficiently strict.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"See also:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"apply_shake!\napply_rattle!\nlangevin_baoab_constrained!","category":"page"},{"location":"specs/Spec_Potentials/#Spec:-Module-Verlet.Potentials","page":"Potentials","title":"Spec: Module Verlet.Potentials","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"Purpose: Define concrete interatomic potentials and per-pair parameter tables; integrate with neighbor lists for efficient force evaluation.","category":"page"},{"location":"specs/Spec_Potentials/#Pair-parameter-structs","page":"Potentials","title":"Pair parameter structs","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"struct LJPair{T<:Number} <: AbstractPotentialPair\nε::T, σ::T, rc::T (cutoff).\nstruct CoulPair{T<:Number} <: AbstractPotentialPair\nq1q2::T (charge product), rc::T.\nstruct PairTable{F<:AbstractPotentialPair}\ntable::Matrix{F} mapping (type_i, type_j) to parameter objects.","category":"page"},{"location":"specs/Spec_Potentials/#Concrete-pair-potentials","page":"Potentials","title":"Concrete pair potentials","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"mutable struct LennardJones{IntT<:Integer, T<:AbstractPotentialPair, T_Float} <: AbstractPairPotential\nFields: params::PairTable{T}, exclusions::Vector{Tuple{IntT,IntT}}, neighbors::PotentialNeighborList{T}, skin::T_Float.\nConstructor: LennardJones(params::PairTable{T}, exclusions, skin) initializes empty neighbor list.\ncompute_forces!(pot::LennardJones, sys::System)\nFor each neighbor (i,j,p), computes minimum-image displacement Δ, r2 = Δ⋅Δ.\nIf r2 < p.rc^2, apply LJ 12-6 force: f = 24ε(2(σ^12/r^13) - (σ^6/r^7)) Δ/‖Δ‖ (implemented in r2 form for efficiency) and accumulate on sys.forces[i]/[j].\nmutable struct Coulomb{IntT<:Integer, T<:AbstractPotentialPair, T_Float} <: AbstractPairPotential\nFields analogous to LennardJones but with CoulPair parameters.\ncompute_forces!(pot::Coulomb, sys::System)\nFor each neighbor within cutoff, f = (q1q2 / r^3) Δ (with minimum-image) and accumulate.","category":"page"},{"location":"specs/Spec_Potentials/#Bonded-potentials-and-instances","page":"Potentials","title":"Bonded potentials and instances","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"Potential parameters\nstruct HarmonicBond{T} <: AbstractBondPotential with k, r0.\nstruct HarmonicAngle{T} <: AbstractAnglePotential with k, θ0.\nstruct PeriodicDihedral{T} <: AbstractDihedralPotential with k, n::Int, ϕ0.\nInteraction instances (bind particles to parameters)\nstruct Bond{T<:AbstractBondPotential} with particles (i,j) and potential::T.\nstruct Angle{T<:AbstractAnglePotential} with (i,j,k) and potential::T.\nstruct Dihedral{T<:AbstractDihedralPotential} with (i,j,k,l) and potential::T.\nForce implementations\ncompute_forces!(bond::Bond, system) harmonic stretch along bond axis.\ncompute_forces!(angle::Angle, system) harmonic deviation of angle at j.\ncompute_forces!(dihedral::Dihedral, system) periodic torsion per OpenMM formulas (throws when system has Dims ≠ 3).","category":"page"},{"location":"specs/Spec_Potentials/#Integration-with-Core.ForceField","page":"Potentials","title":"Integration with Core.ForceField","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"Pair potentials are included in ForceField((lj, coul, ...)) and must have neighbors prebuilt via Neighbors.build_all_neighbors!.\nBonded interactions should be placed in system.specific_potentials for automatic inclusion by compute_all_forces!.","category":"page"},{"location":"specs/Spec_Potentials/#Exclusions","page":"Potentials","title":"Exclusions","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"Each pair potential carries exclusions::Vector{Tuple{Int,Int}} checked by Neighbors.is_excluded during neighbor construction.","category":"page"},{"location":"specs/Spec_Potentials/#Invariants-and-Performance","page":"Potentials","title":"Invariants & Performance","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"neighbors lists are cleared and rebuilt; structure capacity may be retained to avoid allocations.\nForce kernels run allocation-free and scale with neighbor count.","category":"page"},{"location":"specs/Spec_Potentials/#Examples","page":"Potentials","title":"Examples","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"using Verlet, StaticArrays\nbox = CubicBox(8.0)\nR = [@SVector randn(3) for _ in 1:64]; wrap_positions!(R, box)\nsys = System(R, fill(@SVector zeros(3),64), fill(@SVector zeros(3),64), ones(64), box, ones(Int,64), Dict(1=>:A))\n\nparams = PairTable(fill(LJPair(1.0, 1.0, 2.5), (1,1)))\nlj = LennardJones(params, Tuple{Int,Int}[], 0.5)\nff = Verlet.Neighbors.ForceField((lj,))\nmaster = Verlet.Neighbors.MasterNeighborList(sys; cutoff=2.5, skin=0.5)\nVerlet.Neighbors.build_all_neighbors!(master, ff, sys)\nVerlet.Neighbors.compute_all_forces!(sys, ff)","category":"page"},{"location":"specs/Spec_Integrators/#Spec:-Module-Verlet.Integrators","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"","category":"section"},{"location":"specs/Spec_Integrators/","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"Purpose: Provide concrete AbstractIntegrator implementations for common molecular dynamics workflows.","category":"page"},{"location":"specs/Spec_Integrators/#Types","page":"Spec: Module Verlet.Integrators","title":"Types","text":"","category":"section"},{"location":"specs/Spec_Integrators/#Verlet.Integrators.VelocityVerlet","page":"Spec: Module Verlet.Integrators","title":"Verlet.Integrators.VelocityVerlet","text":"VelocityVerlet(dt; wrap=false)\n\nVelocity-Verlet integrator that advances a System in time using the ForceField attached to the system. Set wrap=true to apply periodic wrapping after each position update. The optional callback(system, step) may return false to terminate the integration early.\n\n\n\n\n\n","category":"type"},{"location":"specs/Spec_Integrators/#Verlet.Integrators.ConjugateGradient","page":"Spec: Module Verlet.Integrators","title":"Verlet.Integrators.ConjugateGradient","text":"ConjugateGradient(energy; tol=1e-8, alpha0=1.0, min_alpha=1e-8, c1=1e-4, wrap=true)\n\nPolak–Ribière non-linear conjugate-gradient minimiser. Forces are obtained from the system's ForceField; the user supplies an energy(system) callable used for the line search. The integrator interprets nsteps as the maximum number of iterations. Set wrap=true to apply periodic wrapping after each position update.\n\n\n\n\n\n","category":"type"},{"location":"specs/Spec_Integrators/","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"VelocityVerlet(dt; wrap=false)\nFields: timestep dt, periodic wrapping flag.\nintegrate!(VelocityVerlet, system, nsteps; callback=nothing) performs velocity-Verlet integration using the ForceField attached to system; the callback receives (system, step) and may return false to halt early.\nConjugateGradient(energy; tol=1e-8, alpha0=1.0, min_alpha=1e-8, c1=1e-4, wrap=true)\nImplements non-linear Polak–Ribière conjugate-gradient minimisation with Armijo backtracking. The energy callable must accept the system and return the scalar potential energy. integrate! treats nsteps as the maximum number of line-search iterations.","category":"page"},{"location":"specs/Spec_Integrators/#Behaviour-and-Invariants","page":"Spec: Module Verlet.Integrators","title":"Behaviour & Invariants","text":"","category":"section"},{"location":"specs/Spec_Integrators/","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"integrate! on each integrator mutates the supplied System in place and always updates system.forces with the most recent evaluation.\nCallbacks returning false stop integration early without error.\nNegative nsteps raise ArgumentError.\nPeriodic wrapping is optional (wrap=true wraps positions after each update).","category":"page"},{"location":"specs/Spec_Integrators/#Example","page":"Spec: Module Verlet.Integrators","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Integrators/","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"using Verlet, StaticArrays\n\nstruct Springs\n    k::Float64\nend\n\nfunction Verlet.Core.compute_forces!(pot::Springs, sys::System)\n    @inbounds for i in 1:natoms(sys)\n        sys.forces[i] += -pot.k * sys.positions[i]\n    end\n    return sys\nend\n\nbox = CubicBox(10.0)\nR = [@SVector randn(3) for _ in 1:4]; wrap_positions!(R, box)\nsys = System(R, fill(@SVector zeros(3), 4), fill(@SVector zeros(3), 4), ones(4), box, ones(Int,4), Dict(1=>:A);\n           forcefield=ForceField((Springs(1.0),)))\nvv = VelocityVerlet(0.001)\nintegrate!(vv, sys, 100)","category":"page"},{"location":"specs/Spec_Constraints/#Spec:-Module-Verlet.Constraints","page":"Constraints","title":"Spec: Module Verlet.Constraints","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"Purpose: Represent and enforce pair distance constraints via SHAKE/RATTLE, provide diagnostics and utilities.","category":"page"},{"location":"specs/Spec_Constraints/#Types","page":"Constraints","title":"Types","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"struct DistanceConstraints{T_Int,T_Float}\ni::Vector{T_Int}, j::Vector{T_Int}: constrained pairs (1-based indices).\nr0::Vector{T_Float}: target distances.\ntol::T_Float, maxiter::T_Int: solver tolerance and max iterations.\nuse_minimum_image::Bool: whether to apply minimum-image using sys.box.\nConvenience constructor: DistanceConstraints(pairs::Vector{<:Tuple}, lengths::Vector{<:Real}; tol=1e-8, maxiter=50, use_minimum_image=true).","category":"page"},{"location":"specs/Spec_Constraints/#Solvers","page":"Constraints","title":"Solvers","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"apply_shake!(sys::System, cons::DistanceConstraints, dt)\nIteratively correct positions to satisfy ‖r_i − r_j‖^2 = r0^2 up to tol.\nUses Lagrange multiplier update Δλ = −C/(2σ) with σ = (1/m_i + 1/m_j)‖Δ‖^2.\nErrors if not converged within maxiter or if σ ≈ 0 (ill-conditioned).\napply_rattle!(sys::System, cons::DistanceConstraints)\nCorrect velocities to satisfy Ċ = 2Δ⋅(v_i − v_j) = 0 up to tol.\nSimilar iteration with μ = −(Δ⋅v_rel) / τ, τ = (1/m_i + 1/m_j)‖Δ‖^2.","category":"page"},{"location":"specs/Spec_Constraints/#Time-integration","page":"Constraints","title":"Time integration","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"velocity_verlet_shake_rattle!(sys, forces, dt, cons)\nConstrained velocity-Verlet: half kick → drift → SHAKE → new forces → half kick → RATTLE.","category":"page"},{"location":"specs/Spec_Constraints/#Utilities","page":"Constraints","title":"Utilities","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"remove_com_motion!(sys; which=:velocity|:position|:both)\nRemove center-of-mass motion from velocities and/or positions.\nconstraint_residuals(sys::System, cons::DistanceConstraints) → (; maxC, rmsC, maxCd, rmsCd)\nReports maximum and RMS residuals for positions and velocities.","category":"page"},{"location":"specs/Spec_Constraints/#Performance","page":"Constraints","title":"Performance","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"Each SHAKE/RATTLE sweep is O(#constraints); iteration count depends on tolerance and system state.\nuse_minimum_image reduces discontinuities under PBCs for bonds crossing boundaries.","category":"page"},{"location":"specs/Spec_Constraints/#Failure-modes","page":"Constraints","title":"Failure modes","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"Ill-conditioned constraints (zero-length Δ or huge mass mismatch) may trigger errors.\nNon-convergence raises an error with the configured maxiter.","category":"page"},{"location":"specs/Spec_Constraints/#Example","page":"Constraints","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"using Verlet, StaticArrays\nR = [SVector(0.0,0,0), SVector(1.0,0,0)]\nV = [SVector(0.0,0,0), SVector(0.0,0,0)]\nF = [SVector(0.0,0,0), SVector(0.0,0,0)]\nsys = System(R, V, F, [1.0,1.0], CubicBox(10.0), [1,1], Dict(1=>:A))\ncons = DistanceConstraints([(1,2)], [1.0])\nvelocity_verlet_shake_rattle!(sys, R->F, 0.001, cons)\nres = constraint_residuals(sys, cons)","category":"page"},{"location":"specs/Spec_Thermostats/#Spec:-Module-Verlet.Thermostats","page":"Thermostats","title":"Spec: Module Verlet.Thermostats","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"Purpose: Thermostatting utilities and Langevin BAOAB integrators (un/constrained).","category":"page"},{"location":"specs/Spec_Thermostats/#Degrees-of-freedom-and-temperature","page":"Thermostats","title":"Degrees of freedom and temperature","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"degrees_of_freedom(sys; constraints=nothing, remove_com=false) -> Int\nN*D reduced by number of constraints and optionally by D if COM removed.\ninstantaneous_temperature(sys; kB=1.0)\nT = 2*KE / (kB * dof) using degrees_of_freedom(sys).\nvelocity_rescale!(sys, T; kB=1.0)\nDeterministically rescales velocities by λ = sqrt(T/ max(Tinst, eps())).","category":"page"},{"location":"specs/Spec_Thermostats/#Langevin-BAOAB-(unconstrained)","page":"Thermostats","title":"Langevin BAOAB (unconstrained)","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"langevin_baoab!(sys, forces, dt; γ, temp, kB=1.0, rng=Random.default_rng())\nSplitting: B(½) → A(½) → O → A(½) → B(½).\nOU step uses c = exp(-γ*dt) (with a stable series fallback internally) and noise variance (1-c^2) * kB*temp / m_i per component.\nWith γ=0 reduces to deterministic velocity-Verlet.","category":"page"},{"location":"specs/Spec_Thermostats/#Constrained-Langevin-BAOAB","page":"Thermostats","title":"Constrained Langevin BAOAB","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"langevin_baoab_constrained!(sys, forces, dt, cons::DistanceConstraints; γ, temp, kB=1.0, rng=Random.default_rng())\nSplitting with projections:\nB(½) → apply_rattle!\nA(½) → apply_shake!\nO → apply_rattle!\nA(½) → apply_shake!\nRecompute forces\nB(½) → apply_rattle!\nRecommended path when rigid bonds/constraints are present.","category":"page"},{"location":"specs/Spec_Thermostats/#Invariants-and-Notes","page":"Thermostats","title":"Invariants & Notes","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"All updates are in-place on sys.positions/sys.velocities.\nforces(R) must return a vector of force vectors aligned with R and is called twice per BAOAB step (unconstrained) or once before/after projections (constrained).\nFor reproducibility, pass an explicit RNG.","category":"page"},{"location":"specs/Spec_Thermostats/#Example","page":"Thermostats","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"using Verlet, StaticArrays, Random\nbox = CubicBox(5.0)\nR = [@SVector randn(3) for _ in 1:8]; wrap_positions!(R, box)\nsys = System(R, fill(@SVector zeros(3),8), fill(@SVector zeros(3),8), ones(8), box, ones(Int,8), Dict(1=>:A))\nforces = R -> [ -r for r in R ]\nlangevin_baoab!(sys, forces, 0.001; γ=1.0, temp=1.0, rng=MersenneTwister(1))","category":"page"},{"location":"guide/constraints/#Constrained-Dynamics-(SHAKE/RATTLE)","page":"Constrained Dynamics","title":"Constrained Dynamics (SHAKE/RATTLE)","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"@id constraints-guide","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Molecular simulations often require certain bond lengths (e.g. X–H bonds in water) to remain fixed. This enables larger stable timesteps and enforces realistic rigid-body structures.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Verlet.jl provides support for holonomic distance constraints using the classical SHAKE (positions) and RATTLE (velocities) algorithms.","category":"page"},{"location":"guide/constraints/#Defining-Constraints","page":"Constrained Dynamics","title":"Defining Constraints","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Use DistanceConstraints to define a set of pairwise distance constraints:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using Verlet, StaticArrays\n# A diatomic molecule with target bond length 1.0\npairs   = [(1,2)]\nlengths = [1.0]\ncons = DistanceConstraints(pairs, lengths; tol=1e-10, maxiter=100)","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Arguments:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"pairs: vector of (i,j) atom index pairs (1-based)\nlengths: vector of target distances\ntol: maximum squared violation tolerated (|C_l| units length²)\nmaxiter: maximum SHAKE/RATTLE iterations per step\nuse_minimum_image: apply minimum image convention under periodic boundaries","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"tip: Tip\nFor constraints across periodic boundaries, keep molecules whole and use use_minimum_image=true.","category":"page"},{"location":"guide/constraints/#Constrained-Integrator","page":"Constrained Dynamics","title":"Constrained Integrator","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"The velocity_verlet_shake_rattle! driver advances the system with constraints enforced:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using Verlet, StaticArrays, LinearAlgebra\nN, D = 2, 3\npositions = [@SVector zeros(D) for _ in 1:N]\npositions[2] = @SVector [1.2, 0.0, 0.0]   # initial bond slightly off\nvelocities = [@SVector zeros(D) for _ in 1:N]\nforces = [@SVector zeros(D) for _ in 1:N]\nmasses = ones(N)\nbox = CubicBox(10.0)\ntypes = ones(Int, N)\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names)\ncons = DistanceConstraints([(1,2)], [1.0])\nforces_func(R) = [@SVector zeros(D) for _ in R]  # no external forces\nfor step in 1:100\n  velocity_verlet_shake_rattle!(sys, forces_func, 0.01, cons)\nend\nd = sys.positions[1] - sys.positions[2]\n@show norm(d)  # ~1.0","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"This integrator:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Updates velocities (half step) and positions (drift).\nApplies SHAKE projection to enforce bond lengths.\nRecomputes forces.\nCompletes velocity update.\nApplies RATTLE projection to enforce velocity constraints.","category":"page"},{"location":"guide/constraints/#Degrees-of-Freedom","page":"Constrained Dynamics","title":"Degrees of Freedom","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Constraints reduce the effective number of degrees of freedom (DoF). The degrees_of_freedom function accounts for:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"number of atoms × dimensions\nminus one per constraint\nminus dimensions if COM motion is removed","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using StaticArrays\nN, D = 3, 3\npositions = [@SVector zeros(D) for _ in 1:N]\nvelocities = [@SVector zeros(D) for _ in 1:N]\nforces = [@SVector zeros(D) for _ in 1:N]\nmasses = ones(N)\nbox = CubicBox(10.0)\ntypes = ones(Int, N)\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names)\ncons = DistanceConstraints([(1,2)], [1.0])\ndof = degrees_of_freedom(sys; constraints=cons, remove_com=true)\n@show dof","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Correct DoF is essential for unbiased temperature and pressure estimators.","category":"page"},{"location":"guide/constraints/#Removing-Center-of-Mass-Motion","page":"Constrained Dynamics","title":"Removing Center-of-Mass Motion","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Use remove_com_motion! to zero the mass-weighted center-of-mass velocity or position. This prevents unphysical drift of the entire system.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using StaticArrays\nN, D = 3, 3\npositions = [@SVector zeros(D) for _ in 1:N]\nvelocities = [@SVector ones(D) for _ in 1:N]\nforces = [@SVector zeros(D) for _ in 1:N]\nmasses = [1.0, 2.0, 3.0]\nbox = CubicBox(10.0)\ntypes = ones(Int, N)\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names)\nremove_com_motion!(sys; which=:velocity)\n# After removal, COM velocity should be ~0\nVcom = sum(sys.masses .* map(v -> v[1], sys.velocities)) / sum(sys.masses)\n@show Vcom","category":"page"},{"location":"guide/constraints/#Performance-Notes","page":"Constrained Dynamics","title":"Performance Notes","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"SHAKE/RATTLE typically converge in a few iterations for tree-like molecules.\nFor rings or stiff networks, increase maxiter or relax tol.\nAlways monitor constraint residuals if using larger timesteps.\nThermostat steps that randomize velocities should be followed by apply_rattle!.","category":"page"},{"location":"guide/constraints/#Common-Pitfalls","page":"Constrained Dynamics","title":"Common Pitfalls","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Constraints assume well-defined molecular topology. If your system uses PBC,\nensure constrained atoms belong to the same molecule and do not cross cell boundaries unexpectedly.\nA too-tight tolerance can lead to slow or failed convergence.\nDoF reduction is essential: forgetting to pass constraints or remove_com to degrees_of_freedom will bias temperature estimates.","category":"page"},{"location":"guide/constraints/#Further-Reading","page":"Constrained Dynamics","title":"Further Reading","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Ryckaert, Ciccotti & Berendsen (1977), Numerical integration of the Cartesian equations of motion of a system with constraints: molecular dynamics of n-alkanes, J. Comp. Phys. 23(3).\nAndersen (1983), RATTLE: A \"velocity\" version of the SHAKE algorithm for molecular dynamics calculations, J. Comp. Phys. 52(1).","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"These classical references describe the original SHAKE and RATTLE algorithms implemented here.","category":"page"},{"location":"guide/constraints/#Note-on-Particle-Representation","page":"Constrained Dynamics","title":"Note on Particle Representation","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"All positions, velocities, and forces are now represented as Vector{SVector{D, T}} for performance and type stability. Update your code and constraint definitions accordingly.","category":"page"},{"location":"guide/constraints/#See-Also","page":"Constrained Dynamics","title":"See Also","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"System: container for positions, velocities, and masses.\nVelocityVerlet: unconstrained Velocity-Verlet integrator.\ndegrees_of_freedom: count effective translational degrees of freedom.\nremove_com_motion!: eliminate center-of-mass drift.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"For thermostatting with constraints, project velocities with apply_rattle! after randomization steps to remain on the constraint manifold.","category":"page"},{"location":"guide/constraints/#Next-Steps","page":"Constrained Dynamics","title":"Next Steps","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"You can now combine constrained dynamics with neighbor lists, Lennard-Jones forces, and thermostats. See the Forces & Potentials guide for force field setup.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Summary: SHAKE/RATTLE constraints in Verlet.jl let you simulate rigid bonds, stabilize molecules, and safely increase integration timesteps. Use them with care, monitor convergence, and adjust tolerances as needed.","category":"page"},{"location":"specs/Spec_Verlet/#Spec:-Module-Verlet","page":"Top-level (Verlet)","title":"Spec: Module Verlet","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"Purpose: Provide a cohesive top-level API by loading internal submodules and re-exporting core types and functions for users.\nSubmodules: Core, Neighbors, Potentials, Constraints, Thermostats (and Electrostatics WIP).","category":"page"},{"location":"specs/Spec_Verlet/#Re-exports-(user-facing)","page":"Top-level (Verlet)","title":"Re-exports (user-facing)","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"Core: System, natoms, natomtypes, AbstractBox, CubicBox, minimum_image, wrap_positions!, box_length, AbstractIntegrator, integrate!, potential_energy, kinetic_energy, T_Float, T_Int, Dims.\nIntegrators: VelocityVerlet, ConjugateGradient.\nNeighbor types: NeighborPair, PotentialNeighborList, MasterNeighborList.\nPotential types: AbstractPotentialPair, AbstractPairPotential, AbstractBondPotential, AbstractAnglePotential, AbstractDihedralPotential, AbstractImproperPotential.\nConcrete potentials: LennardJones, Coulomb, LJPair, CoulPair, PairTable, Bond, Angle, Dihedral, HarmonicBond, HarmonicAngle, PeriodicDihedral.\nNeighbor building / forcefield: build_master_neighborlist!, build_cellgrid, rebin!, ForceField, brute_force_pairs.\nConstraints: DistanceConstraints, apply_shake!, apply_rattle!, velocity_verlet_shake_rattle!, remove_com_motion!, constraint_residuals.\nThermostats: degrees_of_freedom, instantaneous_temperature, velocity_rescale!, langevin_baoab!, langevin_baoab_constrained!.","category":"page"},{"location":"specs/Spec_Verlet/#Semantics","page":"Top-level (Verlet)","title":"Semantics","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"Importing Verlet is sufficient for most workflows; the above names are available from the top-level module.\nSubmodules can still be accessed directly (e.g., Verlet.Neighbors.ForceField).","category":"page"},{"location":"specs/Spec_Verlet/#Versioning-and-Stability","page":"Top-level (Verlet)","title":"Versioning & Stability","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"Public names re-exported here follow semantic versioning; removals or breaking signature changes increment the major version.\nInternals not re-exported are considered unstable.","category":"page"},{"location":"specs/Spec_Verlet/#Example","page":"Top-level (Verlet)","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"using Verlet, StaticArrays\nbox = CubicBox(10.0)\nR = [@SVector randn(3) for _ in 1:64]; wrap_positions!(R, box)\nsys = System(R, fill(@SVector zeros(3), 64), fill(@SVector zeros(3), 64), ones(64), box, ones(Int,64), Dict(1=>:A))\nKE = kinetic_energy(sys)","category":"page"},{"location":"specs/Spec_Core/#Spec:-Module-Verlet.Core","page":"Core","title":"Spec: Module Verlet.Core","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"Purpose: Core particle system types, math utilities, simple integrators, and force orchestration.","category":"page"},{"location":"specs/Spec_Core/#Constants","page":"Core","title":"Constants","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"T_Float = Float64: Default floating type for numeric fields.\nT_Int = Int64: Default integer type for indices/types.\nDims = 3: Default spatial dimensionality (APIs accept any D).","category":"page"},{"location":"specs/Spec_Core/#Boxes","page":"Core","title":"Boxes","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"abstract type AbstractBox{T<:AbstractFloat}: Base for boundary conditions.\nstruct CubicBox{T<:AbstractFloat} <: AbstractBox{T}\nFields: L::T (box side length).\nbox_length(box::CubicBox) -> T\nminimum_image(Δ::AbstractVector, box::CubicBox) and minimum_image(Δ, L)\nWrap displacement to (−L/2, L/2] componentwise.\nwrap_positions!(R::Vector{SVector{D,T}}, box::CubicBox{T})\nIn-place wrap of positions to primary cell using minimum image.","category":"page"},{"location":"specs/Spec_Core/#System-and-Particles","page":"Core","title":"System and Particles","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"struct System{T<:AbstractFloat,IT<:Integer,Dims}\nFields:\npositions::Vector{SVector{Dims,T}}\nvelocities::Vector{SVector{Dims,T}}\nforces::Vector{SVector{Dims,T}}\nmasses::Vector{T}\nbox::AbstractBox{T}\ntypes::Vector{IT}\ntype_names::Dict{IT,Symbol}\nnatoms::IT (derived at construction)\nspecific_potentials::Tuple (bonded interactions)\nforcefield: object supplying compute_forces! (typically a ForceField) or nothing\nInvariants:\nAll particle arrays have equal length natoms.\npositions[i], velocities[i], forces[i] are length-Dims SVectors.\nnatoms(sys::System) -> Integer\nnatomtypes(sys::System) -> Int\nkinetic_energy(sys::System{T}) -> T","category":"page"},{"location":"specs/Spec_Core/#Abstract-Potential-Tags","page":"Core","title":"Abstract Potential Tags","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"AbstractPotentialPair, AbstractPairPotential, AbstractBondPotential, AbstractAnglePotential, AbstractDihedralPotential, AbstractImproperPotential.\nMarker types used by potentials for dispatch; no fields or behavior here.","category":"page"},{"location":"specs/Spec_Core/#Neighbor-Types-(tags)","page":"Core","title":"Neighbor Types (tags)","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"abstract type AbstractNeighborList end\nConcrete neighbor structures live in Neighbors and are used by Core APIs via dispatch.","category":"page"},{"location":"specs/Spec_Core/#Forces-and-ForceField","page":"Core","title":"Forces and ForceField","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"struct ForceField{ForcesTuple}\nlayers::ForcesTuple where each layer is a concrete potential (e.g., LennardJones, Coulomb).\nGeneric multimethod hooks:\ncompute_forces!(pot, sys::System) must be implemented by each potential.\ncompute_all_forces!(sys::System, ff::ForceField)\nResets sys.forces to zero element and accumulates contributions from each layer in ff.layers, followed by bonded sys.specific_potentials.\nRequires per-layer neighbor lists to be prepared beforehand (e.g., via Neighbors.build_all_neighbors!).\ncompute_all_forces!(sys::System)\nUses the sys.forcefield; throws if none is attached.","category":"page"},{"location":"specs/Spec_Core/#Integrators","page":"Core","title":"Integrators","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"AbstractIntegrator\nMarker supertype for all time integration / minimisation schemes.\nintegrate!(integrator::AbstractIntegrator, system::System, nsteps; kwargs...)\nPrimary interface each integrator must overload. Contracts for keywords (e.g. callback) are defined by the concrete implementation.\npotential_energy(system::System{T}, forces::Function) -> T\nExpects forces(R; return_potential=true) => (F, U); errors if unsupported.","category":"page"},{"location":"specs/Spec_Core/#Performance-and-Complexity","page":"Core","title":"Performance & Complexity","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"All per-particle loops are O(N). Force complexity depends on neighbor list size and potential implementations.\nwrap_positions! and minimum_image are allocation-free for SVector inputs.","category":"page"},{"location":"specs/Spec_Core/#Error-Handling","page":"Core","title":"Error Handling","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"System constructor asserts matching array sizes.\npotential_energy throws if forces does not accept the return_potential=true keyword.","category":"page"},{"location":"specs/Spec_Core/#Example","page":"Core","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"using Verlet.Core, Verlet.Integrators, StaticArrays\nbox = CubicBox(10.0)\nR = [@SVector randn(3) for _ in 1:4]; wrap_positions!(R, box)\nsys = System(R, fill(@SVector zeros(3), 4), fill(@SVector zeros(3), 4), ones(4), box, ones(Int,4), Dict(1=>:A);\n           forcefield=ForceField(()))\nvv = VelocityVerlet(0.001)\nintegrate!(vv, sys, 1)","category":"page"},{"location":"guide/numerics/#NVT-(Langevin-BAOAB)-Thermostat","page":"Numerical Notes","title":"NVT (Langevin BAOAB) Thermostat","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"This guide shows how to run constant-temperature (NVT) dynamics using the Langevin BAOAB integrator and how to monitor/adjust the system temperature with a few convenience tools.","category":"page"},{"location":"guide/numerics/#Why-BAOAB?","page":"Numerical Notes","title":"Why BAOAB?","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Excellent configurational sampling compared to naive Euler–Maruyama.\nRobust for larger dt at a given target T.\nExact Ornstein–Uhlenbeck (OU) substep and only one force evaluation per step.\nWith γ = 0, BAOAB reduces to velocity–Verlet.","category":"page"},{"location":"guide/numerics/#Quick-Start","page":"Numerical Notes","title":"Quick Start","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"# Typical workflow (package API names shown; adapt to your module's name/exports)\nusing Random, StaticArrays\n\nN, D = 64, 3\npositions = [@SVector zeros(D) for _ in 1:N]\nvelocities = [@SVector randn(D) for _ in 1:N]\nmasses = ones(N)\nps = Verlet.Core.System(positions, velocities, masses)\nforces(R) = [ -0.2 .* r for r in R ]  # any user-defined force function\ndt = 0.005      # time step\nγ  = 1.0        # friction [1/time]\nTt = 1.5        # target T  (kB=1.0 here, so T is in energy units)\nrng = MersenneTwister(2025)\n\n# Optional: bring KE near the target quickly\nVerlet.Thermostats.velocity_rescale!(ps, Tt; kB=1.0)\n# Run several steps under NVT\nfor _ in 1:2_000\n\tVerlet.Thermostats.langevin_baoab!(ps, forces, dt; γ=γ, T=Tt, kB=1.0, rng=rng)\nend\n\n@info \"Instantaneous T\" Verlet.Thermostats.instantaneous_temperature(ps; kB=1.0)","category":"page"},{"location":"guide/numerics/#Choosing-γ-and-dt","page":"Numerical Notes","title":"Choosing γ and dt +","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Units: ensure γ is in 1/time and kB*T in energy, consistent with r, v, and m.\nStart with γ*dt ≈ 0.1–1. Larger values overdamp dynamics (OK for sampling; poor for kinetics).\nKeep dt similar to your velocity–Verlet choice at the same force field. BAOAB is often at least as stable. +","category":"page"},{"location":"guide/numerics/#Algorithm-Sketch","page":"Numerical Notes","title":"Algorithm Sketch +","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"BAOAB splits each step into B (half kick) → A (half drift) → O (OU) → A → B. The OU substep uses the exact update v ← c*v + s*ξ with c = exp(-γ*dt) and s = √((1 - c^2) * kB*T / m). See the function docstring for further details, including numerics for small γ*dt. +","category":"page"},{"location":"guide/numerics/#Diagnostics","page":"Numerical Notes","title":"Diagnostics +","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Verlet.Thermostats.instantaneous_temperature(ps; kB) returns the current kinetic temperature using equipartition (dof = N*D for now).\nTime-average Verlet.Thermostats.instantaneous_temperature over many steps (or save to disk) to validate the thermostat. +","category":"page"},{"location":"guide/numerics/#Pitfalls-and-Tips","page":"Numerical Notes","title":"Pitfalls & Tips +","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Mass heterogeneity: compute OU noise per particle using its mass; do not reuse a single scale across species.\nSmall systems: temperature fluctuates strongly; judge convergence statistically.\nReproducibility: always pass an explicit RNG into Verlet.Thermostats.langevin_baoab!.\nNot a thermostat: Verlet.Thermostats.velocity_rescale! is useful for a single \"KE nudge\" but does not produce the correct canonical distribution. +","category":"page"},{"location":"guide/numerics/#API-Reference","page":"Numerical Notes","title":"API Reference","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"@docs Verlet.Thermostats.langevin_baoab! Verlet.Thermostats.instantaneous_temperature Verlet.Thermostats.degrees_of_freedom Verlet.Thermostats.velocity_rescale!","category":"page"},{"location":"guide/forces/#Forces-and-Potentials","page":"Forces & Potentials","title":"Forces & Potentials","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"This page describes how to define and use forces in your simulations.","category":"page"},{"location":"guide/forces/#The-ForceField-API","page":"Forces & Potentials","title":"The ForceField API","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"The recommended way to define forces is using the ForceField API. This API allows you to compose multiple potentials (e.g., Lennard-Jones and Coulomb) in a flexible and efficient way.","category":"page"},{"location":"guide/forces/#Example:-Lennard-Jones","page":"Forces & Potentials","title":"Example: Lennard-Jones","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"Here's how to set up a simple Lennard-Jones simulation:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"using Verlet, StaticArrays, LinearAlgebra\n\n# 1. Set up the system\nbox = CubicBox(10.0)\nR = [@SVector(randn(3)) for _ in 1:64]; wrap_positions!(R, box)\nsys = System(\n    R,\n    [@SVector(zeros(3)) for _ in R],\n    [@SVector(zeros(3)) for _ in R],\n    ones(length(R)),\n    box,\n    ones(Int, length(R)),\n    Dict(1 => :A)\n)\n\n# 2. Define the potential\nϵ = 1.0\nσ = 1.0\nrc = 2.5\nlj_pair = LJPair(ϵ, σ, rc)\nparams = PairTable(fill(lj_pair, (1, 1)))\nexclusions = Tuple{T_Int,T_Int}[]\nlj = LennardJones(params, exclusions, 0.5)\n\n# 3. Create a ForceField\nff = Verlet.Neighbors.ForceField((lj,))\n\n# 4. Build neighbor lists and compute forces\nmaster_skin = 0.5\nmaster_nl = Verlet.Neighbors.MasterNeighborList(sys; cutoff=rc, skin=master_skin)\nVerlet.Neighbors.build_all_neighbors!(master_nl, ff, sys)\nVerlet.Neighbors.compute_all_forces!(sys, ff)\n\n# The forces are now stored in sys.forces\nprintln(sys.forces[1])","category":"page"},{"location":"guide/forces/#Composing-Potentials","page":"Forces & Potentials","title":"Composing Potentials","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"You can easily combine multiple potentials by adding them to the ForceField tuple:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"# lj = LennardJones(...)\n# coul = Coulomb(...)\n# ff = ForceField((lj, coul))","category":"page"},{"location":"guide/forces/#Neighbor-List-Methods","page":"Forces & Potentials","title":"Neighbor List Methods","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"The build_all_neighbors! function uses a master neighbor list to accelerate force calculations. You can choose the method for building this list with the method keyword argument:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"method=:cells (default): Uses a fast, O(N) cell-list algorithm. This is recommended for most systems.\nmethod=:bruteforce: Uses a simple, O(N^2) algorithm. This can be useful for small systems or for debugging.\nmethod=:all_pairs: Includes all pairs of particles, ignoring the cutoff. This is useful for testing or for potentials without a cutoff.","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"Here's how to use it:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"# master_nl = MasterNeighborList(sys; cutoff=rc, skin=master_skin)\n# build_all_neighbors!(master_nl, ff, sys, method=:bruteforce)","category":"page"},{"location":"guide/forces/#Custom-Forces","page":"Forces & Potentials","title":"Custom Forces","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"You can also define custom force functions. To make potential_energy work, your function should return (F, U) when the keyword return_potential=true is provided:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"using Verlet, StaticArrays, LinearAlgebra\nfunction ho_forces(R; return_potential=false)\n    F = [ -r for r in R ]      # k = 1\n    U = 0.5 * sum(norm(r)^2 for r in R)\n    return return_potential ? (F, U) : F\nend\npositions = [@SVector [1.0, 0.0, 0.0]]\nvelocities = [@SVector [0.0, 0.0, 0.0]]\nforces = [@SVector [0.0, 0.0, 0.0]]\nmasses = [1.0]\nbox = CubicBox(10.0)\ntypes = [1]\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names)\n# The potential_energy function needs to be updated to work with the new API\n# For now, I will just call the function\nho_forces(sys.positions)","category":"page"},{"location":"guide/bonded/#Bonded-Potentials","page":"Bonded Potentials","title":"Bonded Potentials","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"Verlet.jl supports a variety of bonded interactions, which are forces that apply to specific groups of atoms (e.g., bonds, angles, dihedrals). These are specified by passing a tuple of interaction objects to the System constructor via the specific_potentials keyword argument.","category":"page"},{"location":"guide/bonded/#Available-Potentials","page":"Bonded Potentials","title":"Available Potentials","text":"","category":"section"},{"location":"guide/bonded/#Harmonic-Bond","page":"Bonded Potentials","title":"Harmonic Bond","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"The harmonic bond potential is given by:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"U(r) = frac12 k (r - r_0)^2","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"It is defined in Verlet.jl as HarmonicBond(k, r0). To apply this potential to a pair of atoms, you create a Bond object:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"bond_potential = HarmonicBond(1000.0, 0.15) # k in kJ/mol/nm^2, r0 in nm\nbond = Bond(1, 2, bond_potential) # Applies to atoms 1 and 2","category":"page"},{"location":"guide/bonded/#Harmonic-Angle","page":"Bonded Potentials","title":"Harmonic Angle","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"The harmonic angle potential is given by:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"U(theta) = frac12 k (theta - theta_0)^2","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"It is defined as HarmonicAngle(k, θ0). To apply it to a triplet of atoms, you create an Angle object:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"angle_potential = HarmonicAngle(100.0, deg2rad(109.5)) # k in kJ/mol/rad^2, θ0 in radians\nangle = Angle(1, 2, 3, angle_potential) # Applies to atoms 1-2-3 (2 is central)","category":"page"},{"location":"guide/bonded/#Periodic-Dihedral","page":"Bonded Potentials","title":"Periodic Dihedral","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"The periodic dihedral (or torsion) potential is given by:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"U(phi) = k (1 + cos(nphi - phi_0))","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"It is defined as PeriodicDihedral(k, n, ϕ0). To apply it to a quadruplet of atoms, you create a Dihedral object:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"dihedral_potential = PeriodicDihedral(10.0, 3, 0.0) # k in kJ/mol, n is integer, ϕ0 in radians\ndihedral = Dihedral(1, 2, 3, 4, dihedral_potential)","category":"page"},{"location":"guide/bonded/#Example-Usage","page":"Bonded Potentials","title":"Example Usage","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"To use these in a simulation, group them into a tuple and pass them to the System:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"bond1 = Bond(1, 2, HarmonicBond(1000.0, 0.15))\nangle1 = Angle(1, 2, 3, HarmonicAngle(100.0, deg2rad(109.5)))\n\nspecific_interactions = (bond1, angle1)\n\nsys = System(\n    ...,\n    specific_potentials=specific_interactions\n)","category":"page"},{"location":"#Verlet.jl","page":"Home","title":"Verlet.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A minimal velocity Verlet integrator for tiny MD-style problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nYou choose the units; just keep them consistent across positions r, velocities v, masses m, forces F, and timestep dt.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Verlet, StaticArrays\n\nstruct Hooke\n    k::Float64\nend\n\nfunction Verlet.Core.compute_forces!(pot::Hooke, sys::System)\n    @inbounds for i in 1:natoms(sys)\n        sys.forces[i] += -pot.k * sys.positions[i]\n    end\n    return sys\nend\n\nbox = CubicBox(10.0)\npositions = [@SVector [1.0, 0.0, 0.0]]\nvelocities = [@SVector [0.0, 0.0, 0.0]]\nforces_storage = [@SVector [0.0, 0.0, 0.0]]\nmasses = [1.0]\ntypes = [1]\ntype_names = Dict(1 => :A)\nff = ForceField((Hooke(1.0),))\nsys = System(positions, velocities, forces_storage, masses, box, types, type_names; forcefield=ff)\n\nvv = VelocityVerlet(0.05)\nintegrate!(vv, sys, 100)\nsys.positions","category":"page"},{"location":"#Harmonic-oscillator","page":"Home","title":"Harmonic oscillator","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Verlet, StaticArrays, LinearAlgebra\n\nstruct HO\n    k::Float64\nend\n\nfunction Verlet.Core.compute_forces!(pot::HO, sys::System)\n    @inbounds for i in 1:natoms(sys)\n        sys.forces[i] += -pot.k * sys.positions[i]\n    end\n    return sys\nend\n\nfunction ho_energy(sys::System, pot::HO)\n    0.5 * pot.k * sum(norm(r)^2 for r in sys.positions)\nend\n\npot = HO(1.0)\npositions = [@SVector [1.0, 0.0, 0.0]]\nvelocities = [@SVector [0.0, 0.0, 0.0]]\nforces = [@SVector [0.0, 0.0, 0.0]]\nmasses = [1.0]\nbox = CubicBox(10.0)\ntypes = [1]\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names;\n           forcefield=ForceField((pot,)))\n\nvv = VelocityVerlet(0.1)\nintegrate!(vv, sys, 100)\n\nho_energy(sys, pot)","category":"page"},{"location":"#Energy-monitoring","page":"Home","title":"Energy monitoring","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Verlet, StaticArrays, LinearAlgebra\n\nstruct HO\n    k::Float64\nend\n\nfunction Verlet.Core.compute_forces!(pot::HO, sys::System)\n    @inbounds for i in 1:natoms(sys)\n        sys.forces[i] += -pot.k * sys.positions[i]\n    end\n    return sys\nend\n\nho_energy(sys::System, pot::HO) = 0.5 * pot.k * sum(norm(r)^2 for r in sys.positions)\n\npot = HO(1.0)\npositions = [@SVector [1.0, 0.0, 0.0]]\nvelocities = [@SVector [0.0, 1.0, 0.0]]\nforces = [@SVector [0.0, 0.0, 0.0]]\nmasses = [1.0]\nbox = CubicBox(10.0)\ntypes = [1]\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names;\n           forcefield=ForceField((pot,)))\ndt = 0.05\n\nenergies = Float64[]\nvv = VelocityVerlet(dt)\nintegrate!(vv, sys, 200;\n           callback = (sys, step) -> begin\n               push!(energies, kinetic_energy(sys) + ho_energy(sys, pot))\n               return nothing\n           end)\n\n(round(minimum(energies), digits=6), round(maximum(energies), digits=6))","category":"page"},{"location":"#ForceField-API-for-Potentials","page":"Home","title":"ForceField API for Potentials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The recommended way to handle pair potentials like Lennard-Jones is with the ForceField API. This provides a flexible way to combine multiple potentials and uses an efficient neighbor list implementation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Verlet, StaticArrays\n\n# 1. Set up a system\nbox = CubicBox(20.0)\nR = [@SVector randn(3) for _ in 1:100]\nwrap_positions!(R, box)\nsys = System(\n    R,\n    [@SVector(zeros(3)) for _ in R],\n    [@SVector(zeros(3)) for _ in R],\n    ones(length(R)),\n    box,\n    ones(Int, length(R)),\n    Dict(1 => :A)\n)\n\n# 2. Define a Lennard-Jones potential\nrc = 2.5\nlj = Verlet.Potentials.LennardJones(\n    Verlet.Potentials.PairTable(fill(Verlet.Potentials.LJPair(1.0, 1.0, rc), (1, 1))),\n    Tuple{Verlet.Core.T_Int,Verlet.Core.T_Int}[],\n    0.5\n)\n\n# 3. Create a ForceField\nff = Verlet.Neighbors.ForceField((lj,))\n\n# 4. Build neighbor lists and compute forces\nmaster_skin = 0.5\nmaster_nl = Verlet.Neighbors.MasterNeighborList(sys; cutoff=rc, skin=master_skin)\nVerlet.Neighbors.build_all_neighbors!(master_nl, ff, sys)\nVerlet.Neighbors.compute_all_forces!(sys, ff)\n\n@show sys.forces[1]","category":"page"},{"location":"#Neighbor-List-Methods","page":"Home","title":"Neighbor List Methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can choose the neighbor list algorithm with the method keyword in build_all_neighbors!:","category":"page"},{"location":"","page":"Home","title":"Home","text":":cells (default): Fast O(N) cell-based algorithm.\n:bruteforce: Slower O(N^2) algorithm for debugging.\n:all_pairs: Includes all pairs, ignoring cutoffs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"rc = 2.5\nmaster_nl = Verlet.Neighbors.MasterNeighborList(sys; cutoff=rc, skin=master_skin)\nVerlet.Neighbors.build_all_neighbors!(master_nl, ff, sys, method=:bruteforce)","category":"page"},{"location":"","page":"Home","title":"Home","text":"build_master_neighborlist! — construct a new master neighbor list.\nwrap_positions! — enforce periodic wrapping of coordinates.","category":"page"},{"location":"","page":"Home","title":"Home","text":"vv = VelocityVerlet(dt) for step in 1:10     Verlet.Neighbors.buildallneighbors!(master_nl, ff, sys)     integrate!(vv, sys, 1) end","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Next Steps\n\nCheck out the \\[Guide → Constrained Dynamics](@ref constraints-guide) section to learn how to:\n\n- Set up bond constraints with [`DistanceConstraints`](@ref)\n- Run constrained dynamics with [`velocity_verlet_shake_rattle!`](@ref)\n\n\n## ForceField API for Potentials\n\nThe recommended way to handle pair potentials like Lennard-Jones is with the `ForceField` API. This provides a flexible way to combine multiple potentials and uses an efficient neighbor list implementation.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@example using Verlet, StaticArrays","category":"page"},{"location":"#1.-Define-a-Lennard-Jones-potential","page":"Home","title":"1. Define a Lennard-Jones potential","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"box = CubicBox(20.0) R = [@SVector randn(3) for _ in 1:100] wrappositions!(R, box) lj = LennardJones(     PairTable(fill(LJPair(1.0, 1.0, 2.5), (1, 1))),     Tuple{TInt,T_Int}[],     0.5 )","category":"page"},{"location":"#2.-Create-a-ForceField","page":"Home","title":"2. Create a ForceField","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ff = ForceField((lj,))","category":"page"},{"location":"#3.-Set-up-the-system-with-the-force-field","page":"Home","title":"3. Set up the system with the force field","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"sys = System(     R,     [@SVector(zeros(3)) for _ in R],     [@SVector(zeros(3)) for _ in R],     ones(length(R)),     box,     ones(Int, length(R)),     Dict(1 => :A);     forcefield=ff )","category":"page"},{"location":"#4.-Build-neighbor-lists-and-compute-forces","page":"Home","title":"4. Build neighbor lists and compute forces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"masterskin = 0.5 buildallneighbors!(ff, sys, masterskin) computeallforces!(sys, ff)","category":"page"},{"location":"","page":"Home","title":"Home","text":"@show sys.forces[1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Neighbor List Methods\n\nYou can choose the neighbor list algorithm with the `method` keyword in `build_all_neighbors!`:\n- `:cells` (default): Fast `O(N)` cell-based algorithm.\n- `:bruteforce`: Slower `O(N^2)` algorithm for debugging.\n- `:all_pairs`: Includes all pairs, ignoring cutoffs.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia buildallneighbors!(ff, sys, master_skin, method=:bruteforce)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n- [`build_master_neighborlist`](@ref) — construct a new master neighbor list.\n- [`wrap_positions!`](@ref) — enforce periodic wrapping of coordinates.\n\n## Further Notes\n\n* [Constraints](@ref) — how SHAKE/RATTLE are applied and how to monitor residuals\n* [Numerical Notes](@ref) — guidance on tolerances, thermostat interaction, and reproducibility\n\n---\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@contents Pages = [\"constraints.md\", \"numerics.md\", \"api.md\"] Depth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"@index Pages = [\"api.md\"] ```","category":"page"},{"location":"specs/Spec_Electrostatics/#Spec:-Module-Verlet.Electrostatics","page":"Electrostatics","title":"Spec: Module Verlet.Electrostatics","text":"","category":"section"},{"location":"specs/Spec_Electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"Purpose: Placeholder for long-range electrostatics algorithms (Ewald/PME/Wolf).","category":"page"},{"location":"specs/Spec_Electrostatics/#Status","page":"Electrostatics","title":"Status","text":"","category":"section"},{"location":"specs/Spec_Electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"Module exists and includes ewald.jl, which currently serves as a scaffold.\nNo public API is exported yet; future work may add parameter types and force kernels integrated with Neighbors and Core.ForceField.","category":"page"},{"location":"specs/Spec_Electrostatics/#Planned-APIs-(non-binding)","page":"Electrostatics","title":"Planned APIs (non-binding)","text":"","category":"section"},{"location":"specs/Spec_Electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"EwaldReal, EwaldReciprocal parameter types and a composite EwaldSum potential.\nPME FFT-based reciprocal-space evaluator hooks.\nCompatibility with PairTable/type-pair parameterization.","category":"page"}]
}
