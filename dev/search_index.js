var documenterSearchIndex = {"docs":
[{"location":"tutorials/thermostat/#Tutorial-4-·-Thermostatted-Dynamics","page":"Tutorial 4 · Thermostatted Dynamics","title":"Tutorial 4 · Thermostatted Dynamics","text":"","category":"section"},{"location":"tutorials/thermostat/","page":"Tutorial 4 · Thermostatted Dynamics","title":"Tutorial 4 · Thermostatted Dynamics","text":"Langevin BAOAB integrates Newton's equations while gently steering the kinetic energy toward a chosen temperature. In this tutorial we add a thermostat to the Lennard-Jones system from Tutorial 2 and track the instantaneous temperature.","category":"page"},{"location":"tutorials/thermostat/#1.-Reuse-the-Lennard-Jones-setup","page":"Tutorial 4 · Thermostatted Dynamics","title":"1. Reuse the Lennard-Jones setup","text":"","category":"section"},{"location":"tutorials/thermostat/","page":"Tutorial 4 · Thermostatted Dynamics","title":"Tutorial 4 · Thermostatted Dynamics","text":"using Random, StaticArrays, Statistics, Verlet\n\nRandom.seed!(2025)\nN = 64\nbox = CubicBox(8.0)\nrandv() = SVector{3}(randn(), randn(), randn())\npositions = [randv() for _ in 1:N]\nwrap_positions!(positions, box)\nvelocities = [randv() for _ in 1:N]\nzero3 = SVector{3}(0.0, 0.0, 0.0)\nforces = fill(zero3, N)\nmasses = fill(1.0, N)\ntypes = ones(Int, N)\ntype_names = Dict(1 => :A)\n\nparams = PairTable(fill(LJPair(1.0, 1.0, 2.5), (1, 1)))\nlj = LennardJones(params, Tuple{T_Int,T_Int}[], 0.4)\nff = ForceField((lj,))\nsys = System(positions, velocities, forces, masses, box, types, type_names;\n             forcefield = ff)","category":"page"},{"location":"tutorials/thermostat/#2.-Prepare-the-thermostat","page":"Tutorial 4 · Thermostatted Dynamics","title":"2. Prepare the thermostat","text":"","category":"section"},{"location":"tutorials/thermostat/","page":"Tutorial 4 · Thermostatted Dynamics","title":"Tutorial 4 · Thermostatted Dynamics","text":"dt = 0.005\nγ = 1.0\nTtarget = 1.5\nrng = MersenneTwister(42)\n\nintegrator = Verlet.Integrators.LangevinBAOAB(dt; γ = γ, temp = Ttarget, rng = rng)","category":"page"},{"location":"tutorials/thermostat/","page":"Tutorial 4 · Thermostatted Dynamics","title":"Tutorial 4 · Thermostatted Dynamics","text":"Optional: rescale velocities once to start near the target temperature.","category":"page"},{"location":"tutorials/thermostat/","page":"Tutorial 4 · Thermostatted Dynamics","title":"Tutorial 4 · Thermostatted Dynamics","text":"Verlet.Thermostats.velocity_rescale!(sys, Ttarget)","category":"page"},{"location":"tutorials/thermostat/#3.-Integrate-and-record-the-temperature-trace","page":"Tutorial 4 · Thermostatted Dynamics","title":"3. Integrate and record the temperature trace","text":"","category":"section"},{"location":"tutorials/thermostat/","page":"Tutorial 4 · Thermostatted Dynamics","title":"Tutorial 4 · Thermostatted Dynamics","text":"samples = Float64[]\nintegrate!(integrator, sys, 2_000; callback = (system, step, _) -> begin\n    push!(samples, Verlet.Thermostats.instantaneous_temperature(system))\n    return nothing\nend)\n\n(mean(samples), std(samples))","category":"page"},{"location":"tutorials/thermostat/","page":"Tutorial 4 · Thermostatted Dynamics","title":"Tutorial 4 · Thermostatted Dynamics","text":"The temperature fluctuates around the target, as expected for Langevin thermostats.","category":"page"},{"location":"tutorials/thermostat/#4.-Constrained-variant","page":"Tutorial 4 · Thermostatted Dynamics","title":"4. Constrained variant","text":"","category":"section"},{"location":"tutorials/thermostat/","page":"Tutorial 4 · Thermostatted Dynamics","title":"Tutorial 4 · Thermostatted Dynamics","text":"If you are also running with holonomic constraints, use LangevinBAOABConstrained and provide the same DistanceConstraints instance used by your constraint solver.","category":"page"},{"location":"tutorials/thermostat/","page":"Tutorial 4 · Thermostatted Dynamics","title":"Tutorial 4 · Thermostatted Dynamics","text":"cons = DistanceConstraints([(1, 2)], [1.0])\nthermo_cons = Verlet.Integrators.LangevinBAOABConstrained(dt, cons;\n    γ = γ, temp = Ttarget, rng = rng)","category":"page"},{"location":"tutorials/thermostat/#Tips","page":"Tutorial 4 · Thermostatted Dynamics","title":"Tips","text":"","category":"section"},{"location":"tutorials/thermostat/","page":"Tutorial 4 · Thermostatted Dynamics","title":"Tutorial 4 · Thermostatted Dynamics","text":"γ*dt controls the relaxation strength. Values in [0.1, 1.0] are typical.\nPass an explicit rng to make runs reproducible.\nAlways compute instantaneous temperatures with the appropriate number of degrees of freedom: degrees_of_freedom(sys; constraints = cons, remove_com = true).","category":"page"},{"location":"tutorials/thermostat/","page":"Tutorial 4 · Thermostatted Dynamics","title":"Tutorial 4 · Thermostatted Dynamics","text":"Congratulations—you now have a complete NVT workflow. Dive into the How-to Guides for deeper control over system setup and the available force-field components.","category":"page"},{"location":"specs/Spec_Neighbors/#Spec:-Module-Verlet.Neighbors","page":"Neighbors","title":"Spec: Module Verlet.Neighbors","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"Purpose: Construct Verlet neighbour lists, manage shared neighbour state for forcefields, and provide utilities for validating pair selection.","category":"page"},{"location":"specs/Spec_Neighbors/#Core-types","page":"Neighbors","title":"Core types","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"struct NeighborPair{F<:AbstractPotentialPair, IntT<:Integer} stores one (i, j) pair together with its per-type parameters pair::F.\nstruct PotentialNeighborList{F, IntT} wraps neighbors::Vector{NeighborPair{F, IntT}}; pair potentials create instances via PotentialNeighborList(eltype(params.table)) so the stored element type matches their parameter table.\nmutable struct ForceField{Layers}\nFields: layers::Layers, master::Any, master_method::Symbol.\nConstructor: ForceField(layers; method=:cells) initialises master to nothing (pair-potentials present) or EmptyNeighborList().\nSpecialised prepare_neighbors!(ff::ForceField, sys::System) (extending Verlet.Core.prepare_neighbors!) ensures a MasterNeighborList exists, updates its cutoff/skin, rebuilds if needed, and then calls build_neighbors_from_master! for each pair potential in layers.\nstruct EmptyNeighborList end acts as a sentinel when no pair potentials are present.","category":"page"},{"location":"specs/Spec_Neighbors/#Master-neighbour-list","page":"Neighbors","title":"Master neighbour list","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"mutable struct MasterNeighborList{D,T}\nFields: cutoff, cutoff2, skin, rskin2, pairs::Vector{SVector{2,Int}}, r0::Vector{SVector{D,T}}, max_disp2::T, nbuilds::Int, ncells::NTuple{D,Int}, and reusable buffers head::Vector{Int}, next::Vector{Int} for the cell-linked build.\nConstructors: MasterNeighborList(sys::System; cutoff, skin) and MasterNeighborList(positions, box; cutoff, skin).\nrebuild!(nl, sys_or_positions; method=:cells, cutoff=nl.cutoff) refreshes stored pairs using either the cell-linked sweep, a bruteforce fallback (:bruteforce), or an all-pairs builder (:all_pairs). Buffers are resized as needed while retaining allocations between calls.\nbuild_master_neighborlist!(nl, sys; r_verlet, method=:cells) converts the requested Verlet radius to an internal cutoff (max(0, r_verlet - nl.skin) except for :all_pairs) before delegating to rebuild!.\nrebuild_neighbors!(system::System, master::MasterNeighborList; kwargs...) extends Verlet.Core.rebuild_neighbors! and simply calls build_all_neighbors!(master, system.forcefield, system; kwargs...).\nmaybe_rebuild(system::System, master::MasterNeighborList; kwargs...) (defined here via Core.maybe_rebuild) measures the maximum squared displacement of particles since r0; when it exceeds (skin/2)^2, the neighbour list is rebuilt.","category":"page"},{"location":"specs/Spec_Neighbors/#Building-per-potential-neighbours","page":"Neighbors","title":"Building per-potential neighbours","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"build_neighbors_from_master!(pot::AbstractPairPotential, sys::System, master::MasterNeighborList) clears pot.neighborlist, iterates master.pairs, applies minimum-image displacements, skips is_excluded(pot, i, j), and keeps neighbours within (rc + pot.skin)^2.\nis_excluded(pot::AbstractPairPotential, i, j) performs a simple tuple-membership test on pot.exclusions (overridable for efficiency).\nbuild_all_neighbors!(master::MasterNeighborList, ff::ForceField, sys::System; method=:cells)\nCollects pair potentials from ff.layers.\nEnsures the master list covers the largest (rc + skin) amongst them.\nRebuilds each potential’s neighbour list from master.","category":"page"},{"location":"specs/Spec_Neighbors/#Supporting-utilities","page":"Neighbors","title":"Supporting utilities","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"brute_force_pairs(sys::System, cutoff) (and the positions, box, cutoff variant) returns all (i, j) pairs within the squared cutoff using the minimum-image convention; useful for validation.\n_build_pairs_cells!, _build_pairs_bruteforce!, and _build_pairs_allpairs! (internal) implement the various pair-generation strategies.\nDistance helpers displacement and distance2_minimum_image provide allocation-free minimum-image calculations for SVector inputs.","category":"page"},{"location":"specs/Spec_Neighbors/#Cell-grid-helper","page":"Neighbors","title":"Cell-grid helper","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"struct CellGrid{D,IT,T}\nFields: L, cell_size, dims, heads, next.\nBuilt via build_cellgrid(R, box; cell_size) which chooses a uniform grid no finer than the requested cell_size and immediately calls rebin!.\nrebin!(grid, R, box) resets heads/next, bins positions into periodic cells, and can be reused between builds.","category":"page"},{"location":"specs/Spec_Neighbors/#Behaviour-and-invariants","page":"Neighbors","title":"Behaviour & invariants","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"master.pairs always stores unique (i < j) pairs.\nmaster.r0 matches the particle positions when the list was last rebuilt; max_disp2 records the largest squared displacement seen since then.\nPer-potential neighbour lists are cleared before reuse so capacity is retained but contents are refreshed every rebuild.\nThe ForceField keeps the most recent MasterNeighborList instance in ff.master; users may supply a pre-built master list when calling build_all_neighbors! directly.","category":"page"},{"location":"specs/Spec_Neighbors/#Example","page":"Neighbors","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"using Verlet, StaticArrays\n\nbox = CubicBox(8.0)\nR = [SVector{3}(randn(), randn(), randn()) for _ in 1:16]; wrap_positions!(R, box)\nsys = System(R, fill(SVector{3}(0.0, 0.0, 0.0), 16), fill(SVector{3}(0.0, 0.0, 0.0), 16), ones(16), box,\n             ones(Int, 16), Dict(1 => :A))\n\nparams = PairTable(fill(LJPair(1.0, 1.0, 2.5), (1, 1)))\nlj = Verlet.Potentials.LennardJones(params, Tuple{Int,Int}[], 0.3)\nff = ForceField((lj,))\nmaster = MasterNeighborList(sys; cutoff=2.5, skin=0.3)\nbuild_all_neighbors!(master, ff, sys)","category":"page"},{"location":"tutorials/quickstart/#Tutorial-1-·-Hello,-Velocity-Verlet","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"","category":"section"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"This tutorial walks through the minimum ingredients required to step a tiny molecular system with Verlet.jl. We will integrate a single particle tethered by a harmonic spring and peek at the resulting trajectory and energies.","category":"page"},{"location":"tutorials/quickstart/#Prerequisites","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Prerequisites","text":"","category":"section"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"using Verlet, StaticArrays","category":"page"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"The StaticArrays package is convenient for creating the SVector coordinates used throughout Verlet.jl. All other functionality lives in the Verlet module itself.","category":"page"},{"location":"tutorials/quickstart/#1.-Define-a-force-law","page":"Tutorial 1 · Hello, Velocity Verlet","title":"1. Define a force law","text":"","category":"section"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"We implement a tiny Hookean force as a Julia struct plus a compute_forces! overload. This mirrors how you would bring your own potential to the framework.","category":"page"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"using Verlet, StaticArrays\n\nstruct Hooke\n    k::Float64\nend\n\nfunction Verlet.Core.compute_forces!(pot::Hooke, sys::System)\n    @inbounds for i in 1:natoms(sys)\n        sys.forces[i] += -pot.k * sys.positions[i]\n    end\n    return sys\nend","category":"page"},{"location":"tutorials/quickstart/#2.-Build-a-System","page":"Tutorial 1 · Hello, Velocity Verlet","title":"2. Build a System","text":"","category":"section"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"We supply positions, velocities, forces, masses, a periodic box, and particle types. Everything is held in small static vectors for performance.","category":"page"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"box = CubicBox(10.0)\nzero3 = SVector{3}(0.0, 0.0, 0.0)\npositions  = [SVector{3}(1.0, 0.0, 0.0)]\nvelocities = [SVector{3}(0.0, 0.5, 0.0)]\nforces     = [zero3]\nmasses     = [1.0]\ntypes      = [1]\ntype_names = Dict(1 => :A)\n\nhooke = Hooke(1.0)\nff  = ForceField((hooke,))\nsys = System(positions, velocities, forces, masses, box, types, type_names;\n             forcefield = ff)","category":"page"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"At this point we have a fully-specified mechanical system: positions and velocities, an empty force accumulator, masses, and a force field containing our Hookean potential.","category":"page"},{"location":"tutorials/quickstart/#3.-Advance-with-velocity-Verlet","page":"Tutorial 1 · Hello, Velocity Verlet","title":"3. Advance with velocity Verlet","text":"","category":"section"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"Create an integrator, run for a few hundred steps, and capture the trajectory.","category":"page"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"vv = VelocityVerlet(0.05)\ntrajectory = Vector{SVector{3,Float64}}()\nintegrate!(vv, sys, 400; callback = (system, step, _) -> begin\n    push!(trajectory, system.positions[1])\n    return nothing\nend)\n\nlength(trajectory)","category":"page"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"We can look at the final position and total energy:","category":"page"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"final_r = trajectory[end]\nfinal_E = kinetic_energy(sys) + 0.5 * hooke.k * sum(abs2, sys.positions[1])\n(final_r, round(final_E, digits=6))","category":"page"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"Try experimenting with the timestep, mass, or spring constant to see how the motion changes.","category":"page"},{"location":"tutorials/quickstart/#Where-to-go-next","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Where to go next","text":"","category":"section"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"Tutorial 2 · Pair Potentials & Neighbour Lists introduces Lennard-Jones forces and automatic neighbour upkeep.\nBrowse the Building Systems guide for a deeper tour of","category":"page"},{"location":"tutorials/quickstart/","page":"Tutorial 1 · Hello, Velocity Verlet","title":"Tutorial 1 · Hello, Velocity Verlet","text":"the System container and associated helpers.","category":"page"},{"location":"guide/neighbors/#Neighbour-Lists","page":"Neighbour Lists","title":"Neighbour Lists","text":"","category":"section"},{"location":"guide/neighbors/","page":"Neighbour Lists","title":"Neighbour Lists","text":"Efficient pair-force evaluation relies on culling distant particles. Verlet.jl bundles a master neighbour list together with per-potential lists populated on demand. This page summarises the main types and workflows.","category":"page"},{"location":"guide/neighbors/#Master-neighbour-list","page":"Neighbour Lists","title":"Master neighbour list","text":"","category":"section"},{"location":"guide/neighbors/","page":"Neighbour Lists","title":"Neighbour Lists","text":"MasterNeighborList stores candidate pairs within cutoff + skin, caching buffers so rebuilds stay inexpensive. Create one from either a System or raw positions plus box. The list stores all candidate pairs within cutoff + skin and reuses buffers across rebuilds.","category":"page"},{"location":"guide/neighbors/","page":"Neighbour Lists","title":"Neighbour Lists","text":"using Random, StaticArrays, Verlet\n\nRandom.seed!(2)\nN = 16\nbox = CubicBox(6.0)\nrandv() = SVector{3}(randn(), randn(), randn())\nR = [randv() for _ in 1:N]\nwrap_positions!(R, box)\nmaster = MasterNeighborList(R, box; cutoff = 2.5, skin = 0.4)\nlength(master.pairs)","category":"page"},{"location":"guide/neighbors/#ForceField-integration","page":"Neighbour Lists","title":"ForceField integration","text":"","category":"section"},{"location":"guide/neighbors/","page":"Neighbour Lists","title":"Neighbour Lists","text":"Neighbors.ForceField extends Verlet.Core.prepare_neighbors! so that compute_all_forces! rebuilds the master list only when particles move more than skin/2 from their reference positions.","category":"page"},{"location":"guide/neighbors/","page":"Neighbour Lists","title":"Neighbour Lists","text":"params = PairTable(fill(LJPair(1.0, 1.0, 2.5), (1, 1)))\nlj = LennardJones(params, Tuple{T_Int,T_Int}[], 0.4)\nff = ForceField((lj,))","category":"page"},{"location":"guide/neighbors/","page":"Neighbour Lists","title":"Neighbour Lists","text":"When you call compute_all_forces!(sys, ff) or integrate using a System whose forcefield is ff, neighbour lists are prepared automatically.","category":"page"},{"location":"guide/neighbors/#Manual-rebuilds","page":"Neighbour Lists","title":"Manual rebuilds","text":"","category":"section"},{"location":"guide/neighbors/","page":"Neighbour Lists","title":"Neighbour Lists","text":"Sometimes you may want explicit control over neighbour maintenance, for example in Monte Carlo moves. Use build_all_neighbors! with a pre-allocated master list:","category":"page"},{"location":"guide/neighbors/","page":"Neighbour Lists","title":"Neighbour Lists","text":"zero3 = SVector{3}(0.0, 0.0, 0.0)\nsys = System(R, fill(zero3, N), fill(zero3, N),\n             fill(1.0, N), box, ones(Int, N), Dict(1 => :A); forcefield = ff)\n\nVerlet.Neighbors.build_all_neighbors!(master, ff, sys)\nlength(master.pairs)","category":"page"},{"location":"guide/neighbors/","page":"Neighbour Lists","title":"Neighbour Lists","text":"maybe_rebuild(sys, master) checks the maximum squared displacement since the last rebuild and triggers a rebuild only if needed:","category":"page"},{"location":"guide/neighbors/","page":"Neighbour Lists","title":"Neighbour Lists","text":"master_before = length(master.pairs)\n# Perturb positions slightly\nsys.positions .= map(r -> r + 0.25 * randv(), sys.positions)\nmaybe_rebuild(sys, master; method = :cells)\nmaster_after = length(master.pairs)\n(master_before, master_after)","category":"page"},{"location":"guide/neighbors/#Exclusions-and-skins","page":"Neighbour Lists","title":"Exclusions and skins","text":"","category":"section"},{"location":"guide/neighbors/","page":"Neighbour Lists","title":"Neighbour Lists","text":"Every pair potential carries an exclusions::Vector{Tuple{Int,Int}}. The default implementation performs a membership lookup when building the per-potential neighbour list.\nThe per-potential skin is added to each parameter's cutoff when deciding whether to accept a pair from the master list. Choose skin large enough to avoid frequent rebuilds but small enough to keep lists tight.","category":"page"},{"location":"guide/neighbors/#Diagnostics","page":"Neighbour Lists","title":"Diagnostics","text":"","category":"section"},{"location":"guide/neighbors/","page":"Neighbour Lists","title":"Neighbour Lists","text":"Use brute_force_pairs(sys, cutoff) to validate neighbour construction.\nInspect master.max_disp2 to see how far particles travelled since the last rebuild.\nmaster.nbuilds counts how many times the list has been rebuilt—handy for profiling.","category":"page"},{"location":"guide/neighbors/","page":"Neighbour Lists","title":"Neighbour Lists","text":"For a hands-on tour, revisit Tutorial 2 which relies on the automated neighbour management inside ForceField.","category":"page"},{"location":"numerics/#Numerical-Notes","page":"Numerical Notes","title":"Numerical Notes","text":"","category":"section"},{"location":"numerics/#Constraint-Tolerances-and-Thermostat-Parameters","page":"Numerical Notes","title":"Constraint Tolerances and Thermostat Parameters","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"When using LangevinBAOABConstrained, the SHAKE and RATTLE solvers enforce distance constraints up to the tolerance specified in DistanceConstraints.","category":"page"},{"location":"numerics/#Interplay-with-γ-and-T","page":"Numerical Notes","title":"Interplay with γ and T","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Larger friction γ and higher temperature T produce stronger stochastic kicks in the OU step.\nThis may increase the number of iterations needed for constraint convergence.\nIf the solver fails to converge within maxiter, consider relaxing tol slightly.","category":"page"},{"location":"numerics/#Mass-Variance","page":"Numerical Notes","title":"Mass Variance","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Constraints involving very light particles (e.g. hydrogens) can converge more slowly if highly coupled with heavier atoms. This is expected and usually acceptable for simple bond constraints.","category":"page"},{"location":"numerics/#Degrees-of-Freedom-and-Temperature","page":"Numerical Notes","title":"Degrees of Freedom and Temperature","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"The function instantaneous_temperature uses the full degrees of freedom by default. For constrained systems, users who want diagnostics consistent with statistical mechanics should instead call:","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"degrees_of_freedom(sys; constraints=cons, remove_com=false)","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"and use this value in temperature calculations.","category":"page"},{"location":"numerics/#Reproducibility","page":"Numerical Notes","title":"Reproducibility","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"The stochastic step uses the RNG stored in the integrator instance. Set a fixed seed (e.g. rng = MersenneTwister(1234)) in tests or benchmarks for reproducibility.","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"See also: constraint_residuals for monitoring how well constraints are satisfied.","category":"page"},{"location":"tutorials/pair_potentials/#Tutorial-2-·-Pair-Potentials-and-Neighbour-Lists","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"","category":"section"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"This tutorial expands the quickstart example into a small Lennard-Jones fluid. You will learn how to parameterise pair potentials, let ForceField manage neighbour lists, and monitor potential energy during a simulation.","category":"page"},{"location":"tutorials/pair_potentials/#Goal","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Goal","text":"","category":"section"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"Simulate 64 identical particles interacting via a Lennard-Jones (12-6) pair potential inside a cubic periodic box.","category":"page"},{"location":"tutorials/pair_potentials/#1.-Assemble-a-particle-system","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"1. Assemble a particle system","text":"","category":"section"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"using Random, StaticArrays, Verlet\n\nRandom.seed!(2024)\nN = 64\nbox = CubicBox(8.0)\nrandv() = SVector{3}(randn(), randn(), randn())\npositions = [randv() for _ in 1:N]\nwrap_positions!(positions, box)\nzero3 = SVector{3}(0.0, 0.0, 0.0)\nvelocities = fill(zero3, N)\nforces = fill(zero3, N)\nmasses = fill(1.0, N)\ntypes = ones(Int, N)\ntype_names = Dict(1 => :A)","category":"page"},{"location":"tutorials/pair_potentials/#2.-Build-a-Lennard-Jones-potential","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"2. Build a Lennard-Jones potential","text":"","category":"section"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"We store ε, σ, and cutoff r_c in a PairTable. The per-type pair object is looked up automatically using the particle type IDs.","category":"page"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"ϵ  = 1.0\nσ  = 1.0\nrc = 2.5\n\nparams = PairTable(fill(LJPair(ϵ, σ, rc), (1, 1)))\nexclusions = Tuple{T_Int, T_Int}[]\nlj = LennardJones(params, exclusions, 0.5)\nff = ForceField((lj,))","category":"page"},{"location":"tutorials/pair_potentials/#3.-Construct-the-system-with-forces-attached","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"3. Construct the system with forces attached","text":"","category":"section"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"sys = System(positions, velocities, forces, masses, box, types, type_names;\n             forcefield = ff)","category":"page"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"The Neighbors.ForceField stores an internal master neighbour list. It lazily initialises that list the first time compute_all_forces! (or integrate!) is invoked.","category":"page"},{"location":"tutorials/pair_potentials/#4.-Run-dynamics-and-monitor-energy","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"4. Run dynamics and monitor energy","text":"","category":"section"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"We run unconstrained velocity Verlet for a short trajectory and capture the potential energy after each step.","category":"page"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"vv = VelocityVerlet(5e-3)\nenergies = Float64[]\nintegrate!(vv, sys, 200; callback = (system, step, _) -> begin\n    push!(energies, compute_potential_energy(system))\n    return nothing\nend)\n\nminimum(energies), maximum(energies)","category":"page"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"compute_potential_energy(system) automatically rebuilds neighbour lists when particles move more than half the skin distance since the last build.","category":"page"},{"location":"tutorials/pair_potentials/#5.-Inspect-neighbours-explicitly","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"5. Inspect neighbours explicitly","text":"","category":"section"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"You can trigger a manual neighbour rebuild and examine the stored pairs:","category":"page"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"master = MasterNeighborList(sys; cutoff = rc, skin = lj.skin)\nVerlet.Neighbors.build_all_neighbors!(master, ff, sys)\nlength(master.pairs)","category":"page"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"Each pair is an SVector{2,Int} containing (i, j) indices. Concrete pair potentials maintain their own neighbour lists derived from this master object.","category":"page"},{"location":"tutorials/pair_potentials/#Recap-and-next-steps","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Recap & next steps","text":"","category":"section"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"Pair potentials are parameterised via PairTables and added to a Neighbors.ForceField.\nNeighbour lists rebuild automatically during compute_all_forces! and can be inspected or forced manually.\nEnergies can be sampled in a callback during integrate!.","category":"page"},{"location":"tutorials/pair_potentials/","page":"Tutorial 2 · Pair Potentials & Neighbour Lists","title":"Tutorial 2 · Pair Potentials & Neighbour Lists","text":"Continue with Tutorial 3 · Constraints in Practice to enforce rigid bonds during the dynamics.","category":"page"},{"location":"specs/Spec_Module_Index/#Spec-Index","page":"Overview","title":"Spec Index","text":"","category":"section"},{"location":"specs/Spec_Module_Index/","page":"Overview","title":"Overview","text":"Top-level: Verlet\nCore: Verlet.Core\nNeighbors: Verlet.Neighbors\nIntegrators: Verlet.Integrators\nPotentials: Verlet.Potentials\nConstraints: Verlet.Constraints\nThermostats: Verlet.Thermostats\nElectrostatics: Verlet.Electrostatics","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [\n    Verlet.Core,\n    Verlet.Neighbors,\n    Verlet.Potentials,\n    Verlet.Constraints,\n    Verlet.Thermostats\n]\nOrder = [:function, :type]","category":"page"},{"location":"api/#Verlet.Core.AbstractBox","page":"API Reference","title":"Verlet.Core.AbstractBox","text":"abstract type AbstractBox{T<:AbstractFloat} end\n\nAbstract type for simulation boxes.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Core.AbstractIntegrator","page":"API Reference","title":"Verlet.Core.AbstractIntegrator","text":"abstract type AbstractIntegrator end\n\nMarker supertype for all integration / minimisation schemes.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Core.CubicBox","page":"API Reference","title":"Verlet.Core.CubicBox","text":"struct CubicBox{T<:AbstractFloat} <: AbstractBox{T}\n\nSimple cubic periodic box with side length L.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Core.System","page":"API Reference","title":"Verlet.Core.System","text":"System(T<:AbstractFloat, IT<:Integer, Dims)\n\nA flexible and type-stable container for particle-based simulations.\n\nType Parameters\n\nT<:AbstractFloat: Floating-point type for particle properties (e.g., Float32, Float64).\nIT<:Integer: Integer type for particle indices and types (e.g., Int32, Int64).\nDims: The number of spatial dimensions.\n\nFields\n\npositions::Vector{SVector{Dims, T}}: Particle positions.\nvelocities::Vector{SVector{Dims, T}}: Particle velocities.\nforces::Vector{SVector{Dims, T}}: Forces acting on particles.\nmasses::Vector{T}: Particle masses.\nbox::AbstractBox{T}: Simulation box defining the periodic boundary conditions.\ntypes::Vector{IT}: Particle type identifiers (integers).\ntype_names::Dict{IT, Symbol}: Mapping from type identifiers to descriptive names (e.g., 1 => :H).\nnatoms::IT: Total number of atoms.\nspecific_potentials::Tuple: Optional bonded interactions.\nforcefield: Object providing compute_forces!; typically a ForceField or nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Core.integrate!-Tuple{AbstractIntegrator, System, Integer, Vararg{Any}}","page":"API Reference","title":"Verlet.Core.integrate!","text":"integrate!(integrator::AbstractIntegrator, system::System, nsteps::Integer, args...;\n           callback=nothing, neighbor_kwargs...) -> System\n\nRun integrator against system for nsteps iterations. Concrete integrators must implement this method; the default definition throws. When provided, the callback is invoked after each step! with (system, step, integrator) and may return false to request early termination.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.kinetic_energy-Union{Tuple{System{T, IT, Dims, BOX} where BOX<:AbstractBox{T}}, Tuple{Dims}, Tuple{IT}, Tuple{T}} where {T, IT, Dims}","page":"API Reference","title":"Verlet.Core.kinetic_energy","text":"kinetic_energy(sys::System) -> T\n\nTotal kinetic energy: ∑ ½ mᵢ ‖vᵢ‖².\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.natoms-Tuple{System}","page":"API Reference","title":"Verlet.Core.natoms","text":"natoms(sys::System) -> Integer\n\nGet the number of atoms in the system.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.natomtypes-Tuple{System}","page":"API Reference","title":"Verlet.Core.natomtypes","text":"natomtypes(sys::System) -> Int\n\nGet the number of unique atom types in the system.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.potential_energy-Union{Tuple{D}, Tuple{IT}, Tuple{T}, Tuple{System{T, IT, D, BOX} where BOX<:AbstractBox{T}, Function}} where {T, IT, D}","page":"API Reference","title":"Verlet.Core.potential_energy","text":"potential_energy(system::System{T}, forces::Function) -> T\n\nObtain the potential energy by calling forces(system.positions; return_potential=true). If the force function does not support this protocol, the helper will raise an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.wrap_positions!-Union{Tuple{T}, Tuple{D}, Tuple{Array{StaticArraysCore.SVector{D, T}, 1}, CubicBox{T}}} where {D, T<:AbstractFloat}","page":"API Reference","title":"Verlet.Core.wrap_positions!","text":"wrap_positions!(R, box::CubicBox)\n\nWrap particle positions R into the primary periodic image of box in-place. This is useful before building neighbor lists or measuring displacements.\n\nThe resulting positions will be in the range (-L/2, L/2].\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.CellGrid","page":"API Reference","title":"Verlet.Neighbors.CellGrid","text":"CellGrid{D,IT<:Integer,T<:Real}\n\nLinked-list cell grid for cubic periodic boxes. The domain is split into a uniform dims grid of cubic cells with an intrusive linked list (heads, next) storing particle indices in each cell. This enables O(N) rebinning at fixed density and powers the O(N) neighbor build.\n\nFields\n\nL::T: cubic box length.\ncell_size::T: effective uniform cell width used for binning.\ndims::NTuple{D,IT}: number of cells along each axis (each ≥ 1).\nheads::Vector{IT}: length prod(dims); head index per cell (0 sentinel).\nnext::Vector{IT}: length N; linked list “next” pointer per particle (0).\n\ntip: How `cell_size` is chosen\nbuild_cellgrid computes n = floor(Int, L/cell_size) and then uses the effective width L/n for indexing so that a (3ᵈ) stencil is sufficient for a search radius ≤ cell_size.\n\nwarning: Units\nR and L must be expressed in the same length units.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Neighbors.MasterNeighborList","page":"API Reference","title":"Verlet.Neighbors.MasterNeighborList","text":"MasterNeighborList{D,T}\n\nMaster Verlet neighbor list storing unique (i, j) candidates within cutoff + skin for a D-dimensional periodic system. The list retains buffers used by the cell-linked builder so repeated rebuilds avoid allocations.\n\nCreate instances via MasterNeighborList(sys; cutoff, skin) or MasterNeighborList(positions, box; cutoff, skin).\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Neighbors.build_cellgrid-Tuple{AbstractVector, Any}","page":"API Reference","title":"Verlet.Neighbors.build_cellgrid","text":"build_cellgrid(R, box; cell_size)\n\nCreate a new CellGrid sized for cell_size and bin positions R (N×D). Returns a populated grid with linked lists set for particle indices 1..N.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.build_master_neighborlist!-Union{Tuple{T}, Tuple{D}, Tuple{MasterNeighborList{D, T}, System}} where {D, T}","page":"API Reference","title":"Verlet.Neighbors.build_master_neighborlist!","text":"build_master_neighborlist!(nl::MasterNeighborList, sys::System; r_verlet, method=:cells)\nbuild_master_neighborlist!(nl::MasterNeighborList, positions, box; r_verlet, method=:cells)\n\nUpdate a MasterNeighborList in-place so that it contains all candidate (i, j) pairs consistent with the requested Verlet radius r_verlet.\n\nmethod chooses the builder:\n\n:cells (default) uses the cell-linked list sweep and is O(N) for large systems.\n:bruteforce walks all i<j pairs (O(N^2)), useful for debugging and validation.\n:all_pairs stores every (i, j) combination regardless of the cutoff.\n\nThe list's cutoff is updated to max(zero(typeof(nl.cutoff)), r_verlet - nl.skin) so that the stored pairs are within cutoff + skin. Returns nl.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.rebin!-Union{Tuple{T}, Tuple{IT}, Tuple{D}, Tuple{Verlet.Neighbors.CellGrid{D, IT, T}, AbstractVector, Any}} where {D, IT<:Integer, T<:Real}","page":"API Reference","title":"Verlet.Neighbors.rebin!","text":"rebin!(grid, R, box) -> grid\n\nReset the grid's heads and next and bin the positions R into cells according to the current cell_size and periodic cubic box box.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Potentials.CoulPair","page":"API Reference","title":"Verlet.Potentials.CoulPair","text":"CoulPair{T<:Number}\n\nParameters for a Coulomb interaction between two particle types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Potentials.LJPair","page":"API Reference","title":"Verlet.Potentials.LJPair","text":"LJPair{T<:Number}\n\nParameters for a Lennard-Jones interaction between two particle types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Potentials.PairTable","page":"API Reference","title":"Verlet.Potentials.PairTable","text":"PairTable{F<:AbstractPotentialPair}\n\nA table to store parameters for each pair of particle types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Constraints.DistanceConstraints","page":"API Reference","title":"Verlet.Constraints.DistanceConstraints","text":"struct DistanceConstraints{T_Int,T_Float}\n\nImmutable set of pairwise distance constraints for SHAKE/RATTLE.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Constraints.apply_rattle!-Tuple{System, DistanceConstraints}","page":"API Reference","title":"Verlet.Constraints.apply_rattle!","text":"apply_rattle!(sys, cons)\n\nCorrect velocities to satisfy velocity constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.apply_shake!-Tuple{System, DistanceConstraints, Any}","page":"API Reference","title":"Verlet.Constraints.apply_shake!","text":"apply_shake!(sys, cons, dt)\n\nIteratively correct positions to satisfy constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.constraint_residuals-Tuple{System, DistanceConstraints}","page":"API Reference","title":"Verlet.Constraints.constraint_residuals","text":"constraint_residuals(sys::System, cons::DistanceConstraints) -> (; maxC, rmsC, maxCd, rmsCd)\n\nCompute the constraint residuals for a system subject to pairwise distance constraints.\n\nFor each constraint l with atoms (i, j) and target distance r0_l:\n\nPosition residual: C_l = ||r_i - r_j||^2 - r0_l^2\nVelocity residual: Ċ_l = 2 (r_i - r_j) ⋅ (v_i - v_j)\n\nReturns a named tuple with maxC, rmsC, maxCd, rmsCd.\n\nExample\n\nsys = System(\n    [SVector(0.0, 0, 0), SVector(1.0, 0, 0)],\n    [SVector(0.0, 0, 0), SVector(0.0, 0, 0)],\n    [SVector(0.0, 0, 0), SVector(0.0, 0, 0)],\n    [1.0, 1.0],\n    CubicBox(10.0),\n    [1, 1],\n    Dict(1 => :A)\n)\ncons = DistanceConstraints([(1,2)], [1.0])\nconstraint_residuals(sys, cons)\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.remove_com_motion!-Tuple{System}","page":"API Reference","title":"Verlet.Constraints.remove_com_motion!","text":"remove_com_motion!(sys; which=:velocity)\n\nRemove center-of-mass motion from velocities/positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.velocity_verlet_shake_rattle!-Tuple{System, Any, Any, DistanceConstraints}","page":"API Reference","title":"Verlet.Constraints.velocity_verlet_shake_rattle!","text":"velocity_verlet_shake_rattle!(sys, forces, dt, cons)\n\nConstrained velocity Verlet step with SHAKE/RATTLE.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.degrees_of_freedom-Tuple{System}","page":"API Reference","title":"Verlet.Thermostats.degrees_of_freedom","text":"degrees_of_freedom(sys; constraints=nothing, remove_com=false) -> Int\n\nEffective translational DoF, reduced by number of constraints and optionally COM removal. This is the canonical method. A no-keyword fallback is provided for backward compatibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.instantaneous_temperature-Union{Tuple{System{T, IT, Dims, BOX} where BOX<:AbstractBox{T}}, Tuple{Dims}, Tuple{IT}, Tuple{T}} where {T, IT, Dims}","page":"API Reference","title":"Verlet.Thermostats.instantaneous_temperature","text":"instantaneous_temperature(sys; kB=1.0) -> Float64\n\nCompute instantaneous temperature via equipartition: T = 2 * KE / (kB * dof).\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.velocity_rescale!-Tuple{System, Real}","page":"API Reference","title":"Verlet.Thermostats.velocity_rescale!","text":"velocity_rescale!(sys, T; kB=1.0)\n\nDeterministically rescale velocities to match target temperature T.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Molecular systems often contain rigid bonds or fixed distances between atoms. These are represented using the DistanceConstraints type and enforced using SHAKE (positions) and RATTLE (velocities).","category":"page"},{"location":"constraints/#Residual-Monitoring","page":"Constraints","title":"Residual Monitoring","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The helper function constraint_residuals reports how well constraints are satisfied at a given state:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"maxC, rmsC — maximum and RMS positional residuals\nmaxCd, rmsCd — maximum and RMS velocity residuals","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"using Verlet, StaticArrays\npositions = [SVector{3}(0.0, 0.0, 0.0), SVector{3}(1.0, 0.0, 0.0)]\nvelocities = [SVector{3}(0.0, 0.0, 0.0) for _ in 1:2]\nforces = [SVector{3}(0.0, 0.0, 0.0) for _ in 1:2]\nmasses = ones(2)\nbox = CubicBox(10.0)\ntypes = [1, 1]\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names)\ncons = DistanceConstraints([(1,2)], [1.0])\nconstraint_residuals(sys, cons)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"These values are useful for debugging and regression testing.","category":"page"},{"location":"constraints/#Usage-with-cBAOAB","page":"Constraints","title":"Usage with cBAOAB","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"When running constrained Langevin dynamics with LangevinBAOABConstrained, residuals should remain close to machine precision (typically 1e-8 or smaller) if the solver tolerance is sufficiently strict.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"See also:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"apply_shake!\napply_rattle!\nLangevinBAOABConstrained","category":"page"},{"location":"specs/Spec_Potentials/#Spec:-Module-Verlet.Potentials","page":"Potentials","title":"Spec: Module Verlet.Potentials","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"Purpose: Concrete interatomic potentials, pair-parameter tables, and bonded interaction definitions that plug into the Core/Neighbors force orchestration.","category":"page"},{"location":"specs/Spec_Potentials/#Pair-parameter-infrastructure","page":"Potentials","title":"Pair-parameter infrastructure","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"struct LJPair{T<:Number} <: AbstractPotentialPair\nFields: ε::T, σ::T, rc::T (cutoff radius).\nstruct CoulPair{T<:Number} <: AbstractPotentialPair\nFields: q1q2::T (charge product) and rc::T.\nstruct PairTable{F<:AbstractPotentialPair} holds a dense Matrix{F} mapping (type_i, type_j) to parameter objects.","category":"page"},{"location":"specs/Spec_Potentials/#Lennard-Jones-potential","page":"Potentials","title":"Lennard-Jones potential","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"mutable struct LennardJones{IntT<:Integer, T<:AbstractPotentialPair, T_Float} <: AbstractPairPotential\nFields: params::PairTable{T}, exclusions::Vector{Tuple{IntT, IntT}}, neighborlist::PotentialNeighborList{T, IntT}, skin::T_Float.\nConstructor: LennardJones(params::PairTable{T}, exclusions, skin) initialises neighborlist with PotentialNeighborList(eltype(params.table)).\ncompute_forces!(pot::LennardJones, sys::System)\nIterates pot.neighborlist.neighbors, applies minimum-image displacements, and accumulates the 12-6 force when r^2 < rc^2.\ncompute_potential_energy(pot::LennardJones, sys::System) sums the standard LJ energy for neighbours within the cutoff.","category":"page"},{"location":"specs/Spec_Potentials/#Coulomb-potential","page":"Potentials","title":"Coulomb potential","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"mutable struct Coulomb{IntT<:Integer, T<:AbstractPotentialPair, T_Float} <: AbstractPairPotential\nFields: params::PairTable{T}, exclusions::Vector{Tuple{IntT, IntT}}, neighborlist::PotentialNeighborList{T}, skin::T_Float (matching the current struct definition).\nConstructor: Coulomb(params::PairTable{T}, exclusions, skin) also uses PotentialNeighborList(eltype(params.table)).\ncompute_forces!(pot::Coulomb, sys::System) computes f = (q₁q₂ / r³) Δ for neighbours within rc.\ncompute_potential_energy(pot::Coulomb, sys::System) accumulates q₁q₂ / r for valid neighbours, skipping zero-distance pairs.","category":"page"},{"location":"specs/Spec_Potentials/#Bonded-interactions","page":"Potentials","title":"Bonded interactions","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"Parameter types:\nstruct HarmonicBond{T} <: AbstractBondPotential (k, r0).\nstruct HarmonicAngle{T} <: AbstractAnglePotential (k, θ0).\nstruct PeriodicDihedral{T} <: AbstractDihedralPotential (k, n::Int, ϕ0).\nInstances binding particle indices to parameters:\nstruct Bond{T<:AbstractBondPotential} with i, j, potential::T.\nstruct Angle{T<:AbstractAnglePotential} with i, j, k, potential::T.\nstruct Dihedral{T<:AbstractDihedralPotential} with i, j, k, l, potential::T.\nForce/energy implementations:\ncompute_forces!(bond::Bond, system) applies the harmonic bond force aligned with the bond axis; compute_potential_energy returns ½k(r − r₀)².\ncompute_forces!(angle::Angle, system) implements the OpenMM-style harmonic angle force; compute_potential_energy uses ½k(θ − θ₀)².\ncompute_forces!(dihedral::Dihedral, system::System{T,IT,3}) evaluates the periodic torsion using 3D cross products; the 2D/ND fallback throws a DomainError indicating the dimensionality requirement. Matching compute_potential_energy returns k(1 + cos(nϕ − ϕ₀)) in 3D and zero otherwise.","category":"page"},{"location":"specs/Spec_Potentials/#Integration-with-Verlet.Neighbors","page":"Potentials","title":"Integration with Verlet.Neighbors","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"Pair potentials expect to be part of a Neighbors.ForceField. During compute_all_forces! the specialised prepare_neighbors! builds or updates a shared MasterNeighborList and re-populates each pot.neighborlist according to params and skin.\nBonded interactions should be provided through system.specific_potentials so they are included automatically after the pairwise layers.\nExclusions are handled by Neighbors.is_excluded, which checks tuple membership in pot.exclusions.","category":"page"},{"location":"specs/Spec_Potentials/#Behaviour-and-invariants","page":"Potentials","title":"Behaviour & invariants","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"Pair potential kernels are allocation-free over SVector positions.\nNeighbour lists are cleared and rebuilt on demand; capacity is reused between builds.\nskin expands the accepted neighbour radius to (rc + skin) when filtering candidates from the master list.","category":"page"},{"location":"specs/Spec_Potentials/#Example","page":"Potentials","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"using Verlet, StaticArrays\n\nbox = CubicBox(6.0)\nR = [SVector{3}(randn(), randn(), randn()) for _ in 1:8]; wrap_positions!(R, box)\nsys = System(R, fill(SVector{3}(0.0, 0.0, 0.0), 8), fill(SVector{3}(0.0, 0.0, 0.0), 8), ones(8), box,\n             ones(Int, 8), Dict(1 => :A))\n\nparams = PairTable(fill(LJPair(1.0, 1.0, 2.5), (1, 1)))\nlj = LennardJones(params, Tuple{Int,Int}[], 0.4)\nff = ForceField((lj,))\ncompute_all_forces!(sys, ff)","category":"page"},{"location":"specs/Spec_Integrators/#Spec:-Module-Verlet.Integrators","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"","category":"section"},{"location":"specs/Spec_Integrators/","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"Purpose: Concrete AbstractIntegrator implementations that operate on Verlet.Core.System objects using the shared forcefield plumbing.","category":"page"},{"location":"specs/Spec_Integrators/#Shared-utilities","page":"Spec: Module Verlet.Integrators","title":"Shared utilities","text":"","category":"section"},{"location":"specs/Spec_Integrators/","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"_ensure_forcefield(system::System) validates that system.forcefield is attached; otherwise an ArgumentError is thrown.\n_update_forces!(system::System) delegates to compute_all_forces!(system, system.forcefield) and returns system.forces.\nLightweight vector helpers (_vecdot, _neg!, _copy!) support conjugate-gradient updates.","category":"page"},{"location":"specs/Spec_Integrators/#Velocity-Verlet","page":"Spec: Module Verlet.Integrators","title":"Velocity-Verlet","text":"","category":"section"},{"location":"specs/Spec_Integrators/","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"struct VelocityVerlet{T} <: AbstractIntegrator\nFields: dt::T, wrap::Bool (wrap positions after each drift when true).\nConstructor: VelocityVerlet(dt::Real; wrap::Bool=false).\nstep!(integrator::VelocityVerlet, system::System)\nCalls _update_forces!, performs the usual half-kick → drift → optional wrap → force refresh → half-kick sequence, and updates velocities/positions in place.","category":"page"},{"location":"specs/Spec_Integrators/#Conjugate-gradient-minimiser","page":"Spec: Module Verlet.Integrators","title":"Conjugate-gradient minimiser","text":"","category":"section"},{"location":"specs/Spec_Integrators/","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"mutable struct ConjugateGradient{T,E} <: AbstractIntegrator\nParameters: tolerance tol, initial step alpha0, minimum step min_alpha, Armijo slope coefficient c1, wrapping flag wrap, and user-supplied energy::E callable.\nHolds a mutable state::CGState record with cached gradients, search direction, backup positions, latest energy, and stopping flags.\nConstructor: ConjugateGradient(energy; tol=1e-8, alpha0=1.0, min_alpha=1e-8, c1=1e-4, wrap=true) promotes numeric types automatically.\nstep! lazily initialises state buffers, computes forces/energy, performs a Polak–Ribière update with Armijo backtracking, and resets the search when slope conditions fail. On convergence or failed line search, the integrator sets state.stop = true so stop_requested(integrator) halts the outer integrate! loop.","category":"page"},{"location":"specs/Spec_Integrators/#Langevin-BAOAB","page":"Spec: Module Verlet.Integrators","title":"Langevin BAOAB","text":"","category":"section"},{"location":"specs/Spec_Integrators/","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"struct LangevinBAOAB{T,RNG} <: AbstractIntegrator\nFields: dt, gamma, temp, kB, wrap, and rng (any AbstractRNG).\nConstructor: LangevinBAOAB(dt; γ, temp, kB=1.0, wrap=false, rng=Random.default_rng()) promotes numeric types.\nstep! performs the BAOAB splitting: deterministic half-kick with current forces, half drift, Ornstein–Uhlenbeck velocity update using shared random normals, second half drift, and final half kick with refreshed forces. Optional wrapping applies after each drift.","category":"page"},{"location":"specs/Spec_Integrators/#Constrained-Langevin-BAOAB","page":"Spec: Module Verlet.Integrators","title":"Constrained Langevin BAOAB","text":"","category":"section"},{"location":"specs/Spec_Integrators/","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"struct LangevinBAOABConstrained{T,RNG} <: AbstractIntegrator\nExtends the unconstrained variant with a constraints::DistanceConstraints field (from Verlet.Constraints).\nConstructor mirrors the unconstrained signature: LangevinBAOABConstrained(dt, constraints; γ, temp, kB=1.0, wrap=false, rng=Random.default_rng()).\nstep! interleaves SHAKE/RATTLE projections after each sub-step so both positions and velocities satisfy the supplied distance constraints.","category":"page"},{"location":"specs/Spec_Integrators/#Behaviour","page":"Spec: Module Verlet.Integrators","title":"Behaviour","text":"","category":"section"},{"location":"specs/Spec_Integrators/","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"All integrators rely on _update_forces!, ensuring neighbour lists are prepared through Neighbors.prepare_neighbors! before forces are consumed.\nintegrate! is provided by Verlet.Core; callbacks returning false or stop_requested(integrator) terminating early are honoured for every integrator.\nTime-stepping mutates the supplied System in place; no copies of particle arrays are made unless an integrator explicitly caches them (e.g. conjugate gradient backups).","category":"page"},{"location":"specs/Spec_Integrators/#Example","page":"Spec: Module Verlet.Integrators","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Integrators/","page":"Spec: Module Verlet.Integrators","title":"Spec: Module Verlet.Integrators","text":"using Verlet, StaticArrays\n\nbox = CubicBox(5.0)\nR = [SVector{3}(randn(), randn(), randn()) for _ in 1:8]; wrap_positions!(R, box)\nsys = System(R, fill(SVector{3}(0.0, 0.0, 0.0), 8), fill(SVector{3}(0.0, 0.0, 0.0), 8), ones(8), box,\n             ones(Int, 8), Dict(1 => :A); forcefield=ForceField(()))\n\nvv = VelocityVerlet(5e-3)\nintegrate!(vv, sys, 10)","category":"page"},{"location":"specs/Spec_Constraints/#Spec:-Module-Verlet.Constraints","page":"Constraints","title":"Spec: Module Verlet.Constraints","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"Purpose: Represent and enforce pair distance constraints via SHAKE/RATTLE, provide diagnostics and utilities.","category":"page"},{"location":"specs/Spec_Constraints/#Types","page":"Constraints","title":"Types","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"struct DistanceConstraints{T_Int,T_Float}\ni::Vector{T_Int}, j::Vector{T_Int}: constrained pairs (1-based indices).\nr0::Vector{T_Float}: target distances.\ntol::T_Float, maxiter::T_Int: solver tolerance and max iterations.\nuse_minimum_image::Bool: whether to apply minimum-image using sys.box.\nConvenience constructor: DistanceConstraints(pairs::Vector{<:Tuple}, lengths::Vector{<:Real}; tol=1e-8, maxiter=50, use_minimum_image=true).","category":"page"},{"location":"specs/Spec_Constraints/#Solvers","page":"Constraints","title":"Solvers","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"apply_shake!(sys::System, cons::DistanceConstraints, dt)\nIteratively correct positions to satisfy ‖r_i − r_j‖^2 = r0^2 up to tol.\nUses Lagrange multiplier update Δλ = −C/(2σ) with σ = (1/m_i + 1/m_j)‖Δ‖^2.\nErrors if not converged within maxiter or if σ ≈ 0 (ill-conditioned).\napply_rattle!(sys::System, cons::DistanceConstraints)\nCorrect velocities to satisfy Ċ = 2Δ⋅(v_i − v_j) = 0 up to tol.\nSimilar iteration with μ = −(Δ⋅v_rel) / τ, τ = (1/m_i + 1/m_j)‖Δ‖^2.","category":"page"},{"location":"specs/Spec_Constraints/#Time-integration","page":"Constraints","title":"Time integration","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"velocity_verlet_shake_rattle!(sys, forces, dt, cons)\nConstrained velocity-Verlet: half kick → drift → SHAKE → new forces → half kick → RATTLE.","category":"page"},{"location":"specs/Spec_Constraints/#Utilities","page":"Constraints","title":"Utilities","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"remove_com_motion!(sys; which=:velocity|:position|:both)\nRemove center-of-mass motion from velocities and/or positions.\nconstraint_residuals(sys::System, cons::DistanceConstraints) → (; maxC, rmsC, maxCd, rmsCd)\nReports maximum and RMS residuals for positions and velocities.","category":"page"},{"location":"specs/Spec_Constraints/#Performance","page":"Constraints","title":"Performance","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"Each SHAKE/RATTLE sweep is O(#constraints); iteration count depends on tolerance and system state.\nuse_minimum_image reduces discontinuities under PBCs for bonds crossing boundaries.","category":"page"},{"location":"specs/Spec_Constraints/#Failure-modes","page":"Constraints","title":"Failure modes","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"Ill-conditioned constraints (zero-length Δ or huge mass mismatch) may trigger errors.\nNon-convergence raises an error with the configured maxiter.","category":"page"},{"location":"specs/Spec_Constraints/#Example","page":"Constraints","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"using Verlet, StaticArrays\nR = [SVector(0.0,0,0), SVector(1.0,0,0)]\nV = [SVector(0.0,0,0), SVector(0.0,0,0)]\nF = [SVector(0.0,0,0), SVector(0.0,0,0)]\nsys = System(R, V, F, [1.0,1.0], CubicBox(10.0), [1,1], Dict(1=>:A))\ncons = DistanceConstraints([(1,2)], [1.0])\nvelocity_verlet_shake_rattle!(sys, R->F, 0.001, cons)\nres = constraint_residuals(sys, cons)","category":"page"},{"location":"specs/Spec_Thermostats/#Spec:-Module-Verlet.Thermostats","page":"Thermostats","title":"Spec: Module Verlet.Thermostats","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"Purpose: Thermostatting utilities (degrees of freedom, temperature estimators, deterministic rescaling).","category":"page"},{"location":"specs/Spec_Thermostats/#Degrees-of-freedom-and-temperature","page":"Thermostats","title":"Degrees of freedom and temperature","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"degrees_of_freedom(sys; constraints=nothing, remove_com=false) -> Int\nN*D reduced by number of constraints and optionally by D if COM removed.\ninstantaneous_temperature(sys; kB=1.0)\nT = 2*KE / (kB * dof) using degrees_of_freedom(sys).\nvelocity_rescale!(sys, T; kB=1.0)\nDeterministically rescales velocities by λ = sqrt(T / max(Tinst, eps())).","category":"page"},{"location":"specs/Spec_Thermostats/#Langevin-Integrators","page":"Thermostats","title":"Langevin Integrators","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"Langevin BAOAB schemes now live in Verlet.Integrators:","category":"page"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"LangevinBAOAB(dt; γ, temp, kB=1.0, wrap=false, rng=Random.default_rng())\nLangevinBAOABConstrained(dt, constraints; γ, temp, kB=1.0, wrap=false, rng=Random.default_rng())","category":"page"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"Each implements step!(integrator, system) and works with integrate!, rebuilding neighbor lists and updating forces via the System's ForceField.","category":"page"},{"location":"specs/Spec_Thermostats/#Example","page":"Thermostats","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"using Verlet, StaticArrays, Random\n\nstruct Springs\n    k::Float64\nend\n\nfunction Verlet.Core.compute_forces!(pot::Springs, sys::System)\n    @inbounds for i in 1:natoms(sys)\n        sys.forces[i] += -pot.k * sys.positions[i]\n    end\n    return sys\nend\n\nbox = CubicBox(5.0)\nR = [SVector{3}(randn(), randn(), randn()) for _ in 1:8]; wrap_positions!(R, box)\nsys = System(R, fill(SVector{3}(0.0, 0.0, 0.0),8), fill(SVector{3}(0.0, 0.0, 0.0),8), ones(8), box, ones(Int,8), Dict(1=>:A);\n           forcefield=ForceField((Springs(1.0),)))\n\nintegrator = Verlet.Integrators.LangevinBAOAB(0.001; γ=1.0, temp=1.0, rng=MersenneTwister(1))\nintegrate!(integrator, sys, 100)","category":"page"},{"location":"guide/constraints/#Constrained-Dynamics","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Distance constraints lock specific inter-particle separations, enabling longer timesteps and rigid fragments. Verlet.jl implements the classic SHAKE/RATTLE family and integrates with both plain velocity Verlet and the Langevin thermostat.","category":"page"},{"location":"guide/constraints/#Defining-constraints","page":"Constrained Dynamics","title":"Defining constraints","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"DistanceConstraints maps atom-index pairs to target lengths and solver tolerances.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Create a constraint set by listing atom index pairs and their target lengths:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using StaticArrays, LinearAlgebra, Verlet\n\npairs   = [(1, 2), (2, 3)]\nlengths = [1.0, 1.0]\ncons = DistanceConstraints(pairs, lengths; tol = 1e-10, maxiter = 100)","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"tol controls the acceptable squared residual |‖r_i - r_j‖² - r₀²|.\nmaxiter bounds the number of SHAKE/RATTLE correction sweeps per timestep.\nSet use_minimum_image = true when constraints may straddle periodic boundaries.","category":"page"},{"location":"guide/constraints/#Applying-constraints-during-integration","page":"Constrained Dynamics","title":"Applying constraints during integration","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Two options are available:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"velocity_verlet_shake_rattle! wraps the standard velocity-Verlet update with SHAKE (position projection) and RATTLE (velocity projection).\nVerlet.Integrators.LangevinBAOABConstrained embeds the same projections in the stochastic BAOAB scheme.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Both require a callable that returns forces for the updated positions. The force function should honour the System stored in the closure.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using StaticArrays, LinearAlgebra, Verlet\n\nN = 2\nzero3 = SVector{3}(0.0, 0.0, 0.0)\npositions = [zero3, SVector{3}(1.05, 0.0, 0.0)]\nvelocities = fill(zero3, N)\nforces = fill(zero3, N)\nmasses = ones(N)\nbox = CubicBox(10.0)\ntypes = ones(Int, N)\ntype_names = Dict(1 => :A)\nff = ForceField(())  # empty forcefield placeholder\nsys = System(positions, velocities, forces, masses, box, types, type_names;\n             forcefield = ff)\n\nforces_fn(R) = begin\n    _ = R\n    Verlet.Core.compute_all_forces!(sys)\n    sys.forces\nend\n\ndt = 0.01\nvelocity_verlet_shake_rattle!(sys, forces_fn, dt, DistanceConstraints([(1, 2)], [1.0]))\nround(norm(sys.positions[1] - sys.positions[2]), digits = 6)","category":"page"},{"location":"guide/constraints/#Diagnostics-and-utilities","page":"Constrained Dynamics","title":"Diagnostics and utilities","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"constraint_residuals returns maximum and RMS residuals for both positions and velocities.\nremove_com_motion! eliminates centre-of-mass drift in velocity or position space, useful prior to applying thermostats or barostats.\nVerlet.Thermostats.degrees_of_freedom accepts the constraints keyword so temperature estimators account for removed degrees of freedom.","category":"page"},{"location":"guide/constraints/#Choosing-tolerances","page":"Constrained Dynamics","title":"Choosing tolerances","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"tol = 1e-8 suffices for most biomolecular applications; tighten to 1e-10 for high-precision energy conservation.\nIncrease maxiter when solving strongly coupled constraint networks (e.g. rings). Failure to converge raises an error so you can respond appropriately.","category":"page"},{"location":"guide/constraints/#Interplay-with-thermostats","page":"Constrained Dynamics","title":"Interplay with thermostats","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Thermostat updates that randomise velocities (e.g. BAOAB) must immediately be followed by RATTLE projection. The constrained Langevin integrator handles this internally; for custom schemes, call apply_rattle!(sys, cons) after modifying velocities.","category":"page"},{"location":"guide/constraints/#Further-reading","page":"Constrained Dynamics","title":"Further reading","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Ryckaert, Ciccotti & Berendsen (1977). Numerical integration of the Cartesian equations of motion of a system with constraints.\nAndersen (1983). RATTLE: A \"velocity\" version of the SHAKE algorithm.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"For a step-by-step build, revisit Tutorial 3 · Constraints in Practice.","category":"page"},{"location":"guide/system/#Building-Systems","page":"Building Systems","title":"Building Systems","text":"","category":"section"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"A Verlet.Core.System bundles together particle data (positions, velocities, forces, masses, types) and the objects required to compute interactions. This page summarises the key fields, constructors, and utility helpers.","category":"page"},{"location":"guide/system/#Core-fields","page":"Building Systems","title":"Core fields","text":"","category":"section"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"The System type stores positions, velocities, forces, masses, particle types, and optional forcefield/bonded interaction hooks. See the API reference for the full constructor signature.","category":"page"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"Each vector of particle data must have the same length. The default element types use Float64 and Int, but any concrete floating-point and integer types can be employed.","category":"page"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"tip: StaticVectors recommended\nPositions, velocities, and forces are stored as Vector{SVector{D,T}}. This choice keeps per-particle operations allocation-free and type-stable. The StaticArrays.jl package offers convenient constructors.","category":"page"},{"location":"guide/system/#Constructing-a-system","page":"Building Systems","title":"Constructing a system","text":"","category":"section"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"using Random, StaticArrays, Verlet\n\nRandom.seed!(1)\nbox = CubicBox(10.0)\nrandv() = SVector{3}(randn(), randn(), randn())\npositions  = [randv() for _ in 1:4]\nzero3 = SVector{3}(0.0, 0.0, 0.0)\nvelocities = fill(zero3, 4)\nforces     = fill(zero3, 4)\nmasses     = fill(1.0, 4)\ntypes      = ones(Int, 4)\ntype_names = Dict(1 => :A)\n\nsys = System(positions, velocities, forces, masses, box, types, type_names)","category":"page"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"No forces are computed yet—the forcefield slot defaults to nothing. Attach a force field to take advantage of automated neighbour management:","category":"page"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"lj = LennardJones(PairTable(fill(LJPair(1.0, 1.0, 2.5), (1, 1))), Tuple{T_Int,T_Int}[], 0.4)\nff = ForceField((lj,))\nsys = System(positions, velocities, forces, masses, box, types, type_names;\n             forcefield = ff)","category":"page"},{"location":"guide/system/#Particle-types-and-metadata","page":"Building Systems","title":"Particle types & metadata","text":"","category":"section"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"types::Vector{IT} stores integer labels per particle. Use them to look up pair parameters from PairTables.\ntype_names::Dict{IT,Symbol} maps labels to human-friendly symbols (handy for output or assigning new parameters).\nAdd your own metadata by storing side tables keyed by particle index—System","category":"page"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"does not attempt to own every attribute.","category":"page"},{"location":"guide/system/#Bonded-interactions","page":"Building Systems","title":"Bonded interactions","text":"","category":"section"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"To add bonds, angles, or dihedrals, populate specific_potentials with the corresponding interaction objects. They are evaluated after the force-field layers during compute_all_forces! and compute_potential_energy.","category":"page"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"bond = Bond(1, 2, HarmonicBond(100.0, 1.0))\nangle = Angle(1, 2, 3, HarmonicAngle(50.0, deg2rad(109.5)))\n\nsys = System(positions, velocities, forces, masses, box, types, type_names;\n             specific_potentials = (bond, angle))","category":"page"},{"location":"guide/system/#Utilities","page":"Building Systems","title":"Utilities","text":"","category":"section"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"natoms(sys) and natomtypes(sys) report particle counts.\nkinetic_energy(sys) returns the total kinetic energy.\nwrap_positions!(R, box) keeps coordinates inside the primary simulation cell.\nmaybe_rebuild(system, master::MasterNeighborList) checks whether a master  neighbour list needs rebuilding (call before force evaluations if managing  neighbours yourself).","category":"page"},{"location":"guide/system/#Common-patterns","page":"Building Systems","title":"Common patterns","text":"","category":"section"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"Allocate once: reuse the same System when scanning parameters or performing temperature ramps—mutate the existing vectors instead of creating new ones each iteration.\nCustom fields: if you require additional arrays (e.g. per-particle dipoles), maintain them separately and keep indices aligned with the core vectors.","category":"page"},{"location":"guide/system/","page":"Building Systems","title":"Building Systems","text":"Continue with Forces & Potentials to learn how custom interactions hook into the forcefield machinery.","category":"page"},{"location":"specs/Spec_Core/#Spec:-Module-Verlet.Core","page":"Core","title":"Spec: Module Verlet.Core","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"Purpose: Foundational particle-system types, periodic-box utilities, abstract potential tags, and shared integration hooks.","category":"page"},{"location":"specs/Spec_Core/#Constants","page":"Core","title":"Constants","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"T_Float = Float64: default floating-point element type used by convenience constructors.\nT_Int = Int64: default integer type for particle indices and type labels.\nDims = 3: default spatial dimensionality; most APIs work for any D through dispatch.","category":"page"},{"location":"specs/Spec_Core/#Boxes","page":"Core","title":"Boxes","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"abstract type AbstractBox{T<:AbstractFloat}: supertype for boundary-condition containers.\nstruct CubicBox{T<:AbstractFloat} <: AbstractBox{T}\nField: L::T (edge length of the cubic cell).\nbox_length(box::CubicBox) -> T returns the stored length.\nminimum_image(Δ::AbstractVector, box::CubicBox) plus specialised SVector methods keep displacements in (−L/2, L/2] componentwise without allocations.\nwrap_positions!(R::Vector{SVector{D,T}}, box::CubicBox{T}) wraps particle positions to the primary cell in place.","category":"page"},{"location":"specs/Spec_Core/#System-container","page":"Core","title":"System container","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"struct System{T<:AbstractFloat,IT<:Integer,Dims,BOX<:AbstractBox{T},FF}\nFields: positions, velocities, forces :: Vector{SVector{Dims,T}}; masses::Vector{T}; box::BOX; types::Vector{IT}; type_names::Dict{IT,Symbol}; natoms::IT; specific_potentials::Tuple; forcefield::FF (typically a Neighbors.ForceField or nothing).\nConstructor checks that all particle arrays share a common length natoms.\nnatoms(sys::System) and natomtypes(sys::System) expose counts derived from stored fields.\nkinetic_energy(sys::System{T}) -> T computes ∑ₖ ½ mₖ ‖vₖ‖² allocation-free.","category":"page"},{"location":"specs/Spec_Core/#Potential-and-neighbour-tags","page":"Core","title":"Potential & neighbour tags","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"AbstractPotential, AbstractPairPotential, AbstractBondPotential, AbstractAnglePotential, AbstractDihedralPotential, AbstractImproperPotential, and AbstractPotentialPair provide dispatch markers for concrete force implementations.\nabstract type AbstractNeighborList end is a placeholder supertype; concrete lists live in Verlet.Neighbors.","category":"page"},{"location":"specs/Spec_Core/#Force-orchestration","page":"Core","title":"Force orchestration","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"compute_forces!(pot::AbstractPotential, sys::System) must be specialised by each potential; the Core fallback throws.\nprepare_neighbors!(ff, sys::System) is a hook for neighbour-aware forcefields. The Core method returns ff unchanged; Verlet.Neighbors specialises it for its ForceField type.\ncompute_all_forces!(sys::System, ff)\nFills sys.forces with zeros, calls prepare_neighbors!, then invokes compute_forces! across ff.layers followed by every entry in sys.specific_potentials.\nReturns the mutated System to support chaining.\ncompute_all_forces!(sys::System) delegates through sys.forcefield, raising an ArgumentError if none is attached.\ncompute_potential_energy(sys::System, ff) mirrors the force routine but accumulates scalar energy contributions via compute_potential_energy(pot, sys) (Core’s default for unknown potentials is zero).\ncompute_potential_energy(sys::System) again delegates through sys.forcefield with the same guard.\npotential_energy(system::System{T}, forces::Function) -> T expects forces(system.positions; return_potential=true) => (F, U) and throws a descriptive error when the callable lacks that protocol.","category":"page"},{"location":"specs/Spec_Core/#Integration-interface","page":"Core","title":"Integration interface","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"abstract type AbstractIntegrator end: parent type for all integrators.\nintegrate!(integrator::AbstractIntegrator, system::System, nsteps::Integer; callback=nothing, neighbor_kwargs...)\nValidates nsteps ≥ 0; nsteps == 0 returns immediately.\nCalls step!(integrator, system) for each iteration and invokes the optional callback with (system, step, integrator); if the callback returns false or stop_requested(integrator) is true, the loop exits early.\nstep!(integrator::AbstractIntegrator, system::System) must be implemented by concrete integrators; the Core definition raises a MethodError.\nrebuild_neighbors! is declared with no methods in Core so that other modules (e.g. Verlet.Neighbors) can extend it.\nmaybe_rebuild(system::System, args...; kwargs...) calls rebuild_neighbors! and returns the last positional argument, offering a lightweight helper for neighbour maintenance.\nstop_requested(::AbstractIntegrator) defaults to false but can be overridden by stateful integrators such as conjugate-gradient minimisation.","category":"page"},{"location":"specs/Spec_Core/#Error-handling-and-complexity","page":"Core","title":"Error handling & complexity","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"System construction asserts consistent vector lengths; violations surface immediately.\nForce/energy helpers fall back to informative errors when a potential lacks the required overload.\nCore loops are O(N); neighbour-related complexity is delegated to specialised modules.","category":"page"},{"location":"specs/Spec_Core/#Example","page":"Core","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"using Verlet, StaticArrays\n\nbox = CubicBox(10.0)\nR = [SVector{3}(randn(), randn(), randn()) for _ in 1:4]; wrap_positions!(R, box)\nzeros3() = SVector{3}(0.0, 0.0, 0.0)\n\nsys = System(R, fill(zeros3(), 4), fill(zeros3(), 4), ones(4), box,\n             ones(Int, 4), Dict(1 => :A); forcefield=ForceField(()))\n\nvv = VelocityVerlet(1e-3)\nintegrate!(vv, sys, 1)","category":"page"},{"location":"specs/Spec_Verlet/#Spec:-Module-Verlet","page":"Top-level (Verlet)","title":"Spec: Module Verlet","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"Purpose: Assemble the submodules (Core, Neighbors, Potentials, Constraints, Integrators, Thermostats, and the WIP Electrostatics) into a cohesive user-facing API.","category":"page"},{"location":"specs/Spec_Verlet/#Re-exports","page":"Top-level (Verlet)","title":"Re-exports","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"Core & integration: System, natoms, natomtypes, AbstractBox, CubicBox, minimum_image, wrap_positions!, box_length, AbstractIntegrator, integrate!, VelocityVerlet, ConjugateGradient, LangevinBAOAB, LangevinBAOABConstrained, potential_energy, compute_potential_energy, kinetic_energy, maybe_rebuild, T_Float, T_Int, Dims.\nNeighbour infrastructure: NeighborPair, PotentialNeighborList, MasterNeighborList, ForceField, build_master_neighborlist!, build_cellgrid, rebin!, brute_force_pairs.\nPotential markers & concretes: AbstractPotentialPair, AbstractPairPotential, AbstractBondPotential, AbstractAnglePotential, AbstractDihedralPotential, AbstractImproperPotential, LennardJones, Coulomb, LJPair, CoulPair, PairTable, Bond, Angle, Dihedral, HarmonicBond, HarmonicAngle, PeriodicDihedral.\nConstraints: DistanceConstraints, apply_shake!, apply_rattle!, velocity_verlet_shake_rattle!, remove_com_motion!, constraint_residuals.\nThermostats: degrees_of_freedom, instantaneous_temperature, velocity_rescale!.","category":"page"},{"location":"specs/Spec_Verlet/#Semantics","page":"Top-level (Verlet)","title":"Semantics","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"using Verlet is sufficient for typical workflows; advanced users can still access submodules directly (e.g. Verlet.Neighbors.ForceField).\nRe-exported names follow the project’s semantic-versioning policy; non-exported internals are considered unstable.","category":"page"},{"location":"specs/Spec_Verlet/#Example","page":"Top-level (Verlet)","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"using Verlet, StaticArrays\n\nbox = CubicBox(10.0)\nR = [SVector{3}(randn(), randn(), randn()) for _ in 1:64]; wrap_positions!(R, box)\nsys = System(R, fill(SVector{3}(0.0, 0.0, 0.0), 64), fill(SVector{3}(0.0, 0.0, 0.0), 64), ones(64), box,\n             ones(Int, 64), Dict(1 => :A))\nke = kinetic_energy(sys)","category":"page"},{"location":"guide/numerics/#Numerical-Notes-and-Best-Practices","page":"Numerical Notes","title":"Numerical Notes & Best Practices","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"This page collects practical advice for choosing timesteps, monitoring energy, and combining integrators with thermostats in Verlet.jl.","category":"page"},{"location":"guide/numerics/#Timestep-heuristics","page":"Numerical Notes","title":"Timestep heuristics","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Start by scanning the largest timestep that conserves total energy for an unconstrained, microcanonical (NVE) run. Monitor kinetic_energy + potential over several hundred steps.\nHolonomic constraints (SHAKE/RATTLE) allow roughly 2× larger timesteps compared with fully flexible bonds.\nStiff bonded terms or strong Lennard-Jones overlaps may necessitate smaller timesteps; consider energy minimisation (e.g. conjugate gradient) before production dynamics.","category":"page"},{"location":"guide/numerics/#Energy-monitoring-pattern","page":"Numerical Notes","title":"Energy monitoring pattern","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"using StaticArrays, Verlet\n\nstruct Hooke\n    k::Float64\nend\n\nfunction Verlet.Core.compute_forces!(pot::Hooke, sys::System)\n    @inbounds for i in 1:natoms(sys)\n        sys.forces[i] += -pot.k * sys.positions[i]\n    end\n    return sys\nend\n\nbox = CubicBox(10.0)\npositions = [SVector{3}(1.0, 0.0, 0.0)]\nvelocities = [SVector{3}(0.0, 1.0, 0.0)]\nforces = [SVector{3}(0.0, 0.0, 0.0)]\nmasses = [1.0]\ntypes = [1]\ntype_names = Dict(1 => :A)\nhooke = Hooke(1.0)\nff = ForceField((hooke,))\nsys = System(positions, velocities, forces, masses, box, types, type_names;\n             forcefield = ff)\n\nvv = VelocityVerlet(0.05)\nenergies = Float64[]\nintegrate!(vv, sys, 400; callback = (system, step, _) -> begin\n    U = 0.5 * hooke.k * sum(abs2, system.positions[1])\n    push!(energies, kinetic_energy(system) + U)\n    return nothing\nend)\n\n(round(minimum(energies), digits = 6), round(maximum(energies), digits = 6))","category":"page"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Use a similar callback to validate new potentials or parameter sets.","category":"page"},{"location":"guide/numerics/#Thermostats","page":"Numerical Notes","title":"Thermostats","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Verlet.Integrators.LangevinBAOAB is a good default for canonical (NVT) sampling; it preserves configurational accuracy and requires only one force evaluation per step.\nSet γ*dt between 0.1 and 1.0. Smaller values retain more ballistic character; larger values overdamp dynamics but still sample the Boltzmann distribution.\nAlways supply an explicit RNG (rng = MersenneTwister(seed)) for reproducible","category":"page"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"dynamics.","category":"page"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"For constrained systems, switch to LangevinBAOABConstrained with the same DistanceConstraints object used by SHAKE/RATTLE.","category":"page"},{"location":"guide/numerics/#Temperature-estimation","page":"Numerical Notes","title":"Temperature estimation","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"T_inst = 2 * kinetic_energy(sys) / (kB * dof)","category":"page"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Use Verlet.Thermostats.instantaneous_temperature(sys; kB) for convenience. Remember to adjust the degrees of freedom:","category":"page"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"cons = DistanceConstraints([(1,2)], [1.0])\nVerlet.Thermostats.degrees_of_freedom(sys; constraints = cons, remove_com = true)","category":"page"},{"location":"guide/numerics/#Random-initial-velocities","page":"Numerical Notes","title":"Random initial velocities","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Draw initial velocities compatible with your target temperature:","category":"page"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"using Random\nRandom.seed!(123)\nTtarget = 1.5\nfor i in eachindex(sys.velocities)\n    sys.velocities[i] = sqrt(Ttarget) * SVector{3}(randn(), randn(), randn())\nend\nVerlet.Thermostats.remove_com_motion!(sys; which = :velocity)","category":"page"},{"location":"guide/numerics/#Troubleshooting","page":"Numerical Notes","title":"Troubleshooting","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Exploding energies: reduce the timestep, minimise initial structures, or double-check force signs. Large overlaps can produce huge forces.\nConstraint failures: diagnose with constraint_residuals. Raise maxiter, loosen tol, or reduce the timestep.\nNeighbour rebuild storms: increase the pair potential skin (e.g. from 0.3 to 0.6) so particles travel farther before triggering a rebuild.","category":"page"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"For a concrete thermostat example, see Tutorial 4 · Thermostatted Dynamics.","category":"page"},{"location":"guide/numerics/#Integrator-API","page":"Numerical Notes","title":"Integrator API","text":"","category":"section"},{"location":"guide/numerics/#Verlet.Integrators.VelocityVerlet","page":"Numerical Notes","title":"Verlet.Integrators.VelocityVerlet","text":"VelocityVerlet(dt; wrap=false)\n\nVelocity-Verlet integrator that advances a System in time using the ForceField attached to the system. Set wrap=true to apply periodic wrapping after each position update. The optional callback supplied to integrate! receives (system, step, integrator) and may return false to terminate early.\n\n\n\n\n\n","category":"type"},{"location":"guide/numerics/#Verlet.Integrators.ConjugateGradient","page":"Numerical Notes","title":"Verlet.Integrators.ConjugateGradient","text":"ConjugateGradient(energy; tol=1e-8, alpha0=1.0, min_alpha=1e-8, c1=1e-4, wrap=true)\n\nPolak–Ribière non-linear conjugate-gradient minimiser. Forces are obtained from the system's ForceField; the user supplies an energy(system) callable used for the Armijo backtracking line search. Each call to step! performs one CG iteration; the integrator maintains internal state so subsequent steps continue from where the previous iteration stopped.\n\n\n\n\n\n","category":"type"},{"location":"guide/numerics/#Verlet.Integrators.LangevinBAOAB","page":"Numerical Notes","title":"Verlet.Integrators.LangevinBAOAB","text":"LangevinBAOAB(dt; γ, temp, kB=1.0, wrap=false, rng=Random.default_rng())\n\nStochastic BAOAB Langevin integrator (unconstrained). Uses the System's ForceField for force evaluations.\n\n\n\n\n\n","category":"type"},{"location":"guide/numerics/#Verlet.Integrators.LangevinBAOABConstrained","page":"Numerical Notes","title":"Verlet.Integrators.LangevinBAOABConstrained","text":"LangevinBAOABConstrained(dt, constraints; γ, temp, kB=1.0, wrap=false, rng=Random.default_rng())\n\nConstrained Langevin BAOAB integrator using SHAKE/RATTLE projections.\n\n\n\n\n\n","category":"type"},{"location":"guide/forces/#Forces-and-Potentials","page":"Forces & Potentials","title":"Forces & Potentials","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"This guide explains how forces plug into Verlet.jl, from bespoke compute_forces! implementations to the built-in Lennard-Jones and Coulomb potentials managed by Neighbors.ForceField.","category":"page"},{"location":"guide/forces/#1.-Bring-your-own-potential","page":"Forces & Potentials","title":"1. Bring your own potential","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"Any concrete type becomes a potential once you implement Verlet.Core.compute_forces!(pot, system). The method must accumulate forces into system.forces and return the system.","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"using Random, StaticArrays, Verlet\n\nRandom.seed!(3)\n\nstruct Springs\n    k::Float64\nend\n\nfunction Verlet.Core.compute_forces!(pot::Springs, sys::System)\n    @inbounds for i in 1:natoms(sys)\n        sys.forces[i] += -pot.k * sys.positions[i]\n    end\n    return sys\nend\n\nfunction Verlet.Core.compute_potential_energy(pot::Springs, sys::System)\n    energy = zero(eltype(sys.positions[1]))\n    @inbounds for i in 1:natoms(sys)\n        energy += 0.5 * pot.k * sum(abs2, sys.positions[i])\n    end\n    return energy\nend","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"Add the potential to a ForceField so it participates in the standard force pipeline:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"springs = Springs(0.25)\nff = ForceField((springs,))","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"During compute_all_forces!(sys, ff) the force accumulator is zeroed, all layers in ff.layers are evaluated, followed by any sys.specific_potentials.","category":"page"},{"location":"guide/forces/#2.-Pair-potentials-with-neighbour-lists","page":"Forces & Potentials","title":"2. Pair potentials with neighbour lists","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"Verlet.jl ships Lennard-Jones and Coulomb interactions that look up parameters from a PairTable based on particle types. The Neighbors.ForceField wrapper manages master neighbour lists behind the scenes.","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"N = 32\nbox = CubicBox(6.0)\nrandv() = SVector{3}(randn(), randn(), randn())\npositions = [randv() for _ in 1:N]\nwrap_positions!(positions, box)\nzero3 = SVector{3}(0.0, 0.0, 0.0)\nvelocities = fill(zero3, N)\nforces = fill(zero3, N)\nmasses = fill(1.0, N)\ntypes = ones(Int, N)\ntype_names = Dict(1 => :A)\n\nparams = PairTable(fill(LJPair(1.0, 1.0, 2.5), (1, 1)))\nlj = LennardJones(params, Tuple{T_Int,T_Int}[], 0.4)\nff = ForceField((springs, lj))\n\nsys = System(positions, velocities, forces, masses, box, types, type_names;\n             forcefield = ff)\nVerlet.Core.compute_all_forces!(sys)  # neighbour lists prepared automatically\nsys.forces[1]","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"Combine multiple pair potentials simply by stacking them inside the tuple. Each layer gets its own per-potential neighbour list derived from the shared master list.","category":"page"},{"location":"guide/forces/#3.-Bonded-interactions","page":"Forces & Potentials","title":"3. Bonded interactions","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"Bonds, angles, and dihedrals operate on explicit particle indices and live in the specific_potentials tuple on the System.","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"bond = Bond(1, 2, HarmonicBond(100.0, 1.0))\nangle = Angle(1, 2, 3, HarmonicAngle(50.0, deg2rad(109.5)))\n\ndata = System(positions, velocities, forces, masses, box, types, type_names;\n              forcefield = ff, specific_potentials = (bond, angle))\nVerlet.Core.compute_all_forces!(data)","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"Bonded terms run after every layer listed in the ForceField, ensuring their contributions accumulate alongside pair forces.","category":"page"},{"location":"guide/forces/#4.-Energy-evaluation","page":"Forces & Potentials","title":"4. Energy evaluation","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"The same building blocks compute potential energy. Supply the forcefield via system.forcefield or pass it explicitly:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"E_pairs = compute_potential_energy(sys)           # uses sys.forcefield\nE_pairs == compute_potential_energy(sys, ff)","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"If you provide a standalone force callback that supports return_potential=true, the helper Verlet.Core.potential_energy(system, forces) extracts the second element of the returned tuple.","category":"page"},{"location":"guide/forces/#5.-When-to-rebuild-neighbours-manually","page":"Forces & Potentials","title":"5. When to rebuild neighbours manually","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"Most workflows rely on the automatic rebuild triggered by compute_all_forces!. You only need manual control when modifying positions without calling the integrator (e.g. Monte Carlo moves). In that case:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"master = MasterNeighborList(sys; cutoff = 2.5, skin = 0.4)\nVerlet.Neighbors.build_all_neighbors!(master, ff, sys)","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"Follow up with maybe_rebuild(sys, master) whenever particle displacements may exceed skin/2.","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"For a tutorial-style walkthrough, see Tutorial 2 · Pair Potentials & Neighbour Lists.","category":"page"},{"location":"guide/bonded/#Bonded-Interactions","page":"Bonded Interactions","title":"Bonded Interactions","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Interactions","title":"Bonded Interactions","text":"Bonded terms capture interactions tied to specific atom tuples—bonds, angles, and dihedrals. They complement pair potentials and are evaluated automatically once added to the specific_potentials tuple on a System.","category":"page"},{"location":"guide/bonded/#Available-interaction-types","page":"Bonded Interactions","title":"Available interaction types","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Interactions","title":"Bonded Interactions","text":"HarmonicBond, HarmonicAngle, and PeriodicDihedral define the parameter families for bonds, angles, and torsions.\nBond, Angle, and Dihedral bind those parameters to explicit atom indices.","category":"page"},{"location":"guide/bonded/#Example:-triatomic-fragment","page":"Bonded Interactions","title":"Example: triatomic fragment","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Interactions","title":"Bonded Interactions","text":"using StaticArrays, Verlet\n\nzero3 = SVector{3}(0.0, 0.0, 0.0)\npositions = [zero3,\n             SVector{3}(1.0, 0.0, 0.0),\n             SVector{3}(1.0, 1.0, 0.0)]\nvelocities = fill(zero3, 3)\nforces = fill(zero3, 3)\nmasses = ones(3)\nbox = CubicBox(10.0)\ntypes = [1, 1, 1]\ntype_names = Dict(1 => :A)\n\nbond = Bond(1, 2, HarmonicBond(200.0, 1.0))\nangle = Angle(1, 2, 3, HarmonicAngle(50.0, deg2rad(109.5)))\n\nff = ForceField(())\ndata = System(positions, velocities, forces, masses, box, types, type_names;\n              forcefield = ff, specific_potentials = (bond, angle))\n\nVerlet.Core.compute_all_forces!(data)\n(data.forces[1], data.forces[2])","category":"page"},{"location":"guide/bonded/#Workflow-tips","page":"Bonded Interactions","title":"Workflow tips","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Interactions","title":"Bonded Interactions","text":"Supply bonded terms via the specific_potentials keyword when constructing a System, or mutate the tuple after construction (sys = sys.with etc.).\nCombine as many interactions as required: the tuple is iterated in order, so you can include custom objects that also implement compute_forces!.\nUse bonded terms alongside neighbour-managed pair potentials by attaching a ForceField and setting specific_potentials simultaneously.","category":"page"},{"location":"guide/bonded/#Debugging","page":"Bonded Interactions","title":"Debugging","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Interactions","title":"Bonded Interactions","text":"If a bonded interaction fails to converge or produces unexpected forces, inspect the angle/dihedral geometry directly—ill-conditioned setups (nearly colinear atoms) can amplify numerical error.\ncompute_potential_energy(bond, system) and friends return the contribution from an individual interaction; sum them to decompose total energy.","category":"page"},{"location":"guide/bonded/","page":"Bonded Interactions","title":"Bonded Interactions","text":"For constrained alternatives (fixed bond lengths), see Tutorial 3 · Constraints in Practice.","category":"page"},{"location":"#Verlet.jl","page":"Home","title":"Verlet.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A lightweight toolkit for molecular dynamics experiments in Julia. Verlet.jl offers composable force fields, neighbour-list acceleration, and convenient drivers for both deterministic and thermostatted dynamics.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From the Julia package REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Verlet","category":"page"},{"location":"","page":"Home","title":"Home","text":"Verify the install and load the main module:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Verlet","category":"page"},{"location":"#A-ten-line-simulation","page":"Home","title":"A ten-line simulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using StaticArrays, Verlet\n\nstruct Hooke\n    k::Float64\nend\n\nfunction Verlet.Core.compute_forces!(pot::Hooke, sys::System)\n    @inbounds for i in 1:natoms(sys)\n        sys.forces[i] += -pot.k * sys.positions[i]\n    end\n    return sys\nend\n\nbox = CubicBox(10.0)\npositions  = [SVector{3}(1.0, 0.0, 0.0)]\nvelocities = [SVector{3}(0.0, 0.5, 0.0)]\nforces     = [SVector{3}(0.0, 0.0, 0.0)]\nmasses     = [1.0]\ntypes      = [1]\ntype_names = Dict(1 => :A)\nff = ForceField((Hooke(1.0),))\nsys = System(positions, velocities, forces, masses, box, types, type_names; forcefield = ff)\n\nvv = VelocityVerlet(0.05)\nintegrate!(vv, sys, 200)\nsys.positions[1]","category":"page"},{"location":"#Documentation-map","page":"Home","title":"Documentation map","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tutorials – follow the numbered lessons: start with Tutorial 1 · Hello, Velocity Verlet and work your way towards pair potentials, constraints, and thermostats.\nHow-to Guides – focused references for day-to-day tasks such as building systems, defining forces, or managing neighbour lists.\nReference – specification sheets for each submodule and the generated API reference when you need precise type signatures.","category":"page"},{"location":"#Highlights","page":"Home","title":"Highlights","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"🔁 Velocity Verlet, conjugate gradient, and Langevin BAOAB integrators.\n⚛️ Built-in Lennard-Jones, Coulomb, and bonded potentials with exclusion support.\n📦 Holonomic constraints (SHAKE/RATTLE) and thermostat-aware variants.\n📚 First-class StaticArrays support for allocation-free inner loops.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ready to dive in? Start with Building Systems or jump straight to the tutorial series.","category":"page"},{"location":"specs/Spec_Electrostatics/#Spec:-Module-Verlet.Electrostatics","page":"Electrostatics","title":"Spec: Module Verlet.Electrostatics","text":"","category":"section"},{"location":"specs/Spec_Electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"Purpose: Placeholder for long-range electrostatics algorithms (Ewald/PME/Wolf).","category":"page"},{"location":"specs/Spec_Electrostatics/#Status","page":"Electrostatics","title":"Status","text":"","category":"section"},{"location":"specs/Spec_Electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"Module exists and includes ewald.jl, which currently serves as a scaffold.\nNo public API is exported yet; future work may add parameter types and force kernels integrated with Neighbors and Core.ForceField.","category":"page"},{"location":"specs/Spec_Electrostatics/#Planned-APIs-(non-binding)","page":"Electrostatics","title":"Planned APIs (non-binding)","text":"","category":"section"},{"location":"specs/Spec_Electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"EwaldReal, EwaldReciprocal parameter types and a composite EwaldSum potential.\nPME FFT-based reciprocal-space evaluator hooks.\nCompatibility with PairTable/type-pair parameterization.","category":"page"},{"location":"tutorials/constraints/#Tutorial-3-·-Constraints-in-Practice","page":"Tutorial 3 · Constraints in Practice","title":"Tutorial 3 · Constraints in Practice","text":"","category":"section"},{"location":"tutorials/constraints/","page":"Tutorial 3 · Constraints in Practice","title":"Tutorial 3 · Constraints in Practice","text":"Rigid constraints let you hold specific distances fixed, enabling larger integration timesteps and faithful rigid fragments (e.g. water molecules). This tutorial uses Verlet.jl's SHAKE/RATTLE implementation to maintain a fixed bond.","category":"page"},{"location":"tutorials/constraints/#Scenario","page":"Tutorial 3 · Constraints in Practice","title":"Scenario","text":"","category":"section"},{"location":"tutorials/constraints/","page":"Tutorial 3 · Constraints in Practice","title":"Tutorial 3 · Constraints in Practice","text":"Simulate a dumbbell molecule with a 1.0 distance between two atoms, using a custom force and the velocity_verlet_shake_rattle! driver.","category":"page"},{"location":"tutorials/constraints/#1.-Define-the-model","page":"Tutorial 3 · Constraints in Practice","title":"1. Define the model","text":"","category":"section"},{"location":"tutorials/constraints/","page":"Tutorial 3 · Constraints in Practice","title":"Tutorial 3 · Constraints in Practice","text":"using LinearAlgebra, StaticArrays, Verlet\n\nstruct Tether\n    k::Float64\nend\n\nfunction Verlet.Core.compute_forces!(pot::Tether, sys::System)\n    # Simple harmonic tether to the origin for each atom\n    @inbounds for i in 1:natoms(sys)\n        sys.forces[i] += -pot.k * sys.positions[i]\n    end\n    return sys\nend","category":"page"},{"location":"tutorials/constraints/#2.-Create-the-constrained-system","page":"Tutorial 3 · Constraints in Practice","title":"2. Create the constrained system","text":"","category":"section"},{"location":"tutorials/constraints/","page":"Tutorial 3 · Constraints in Practice","title":"Tutorial 3 · Constraints in Practice","text":"zero3 = SVector{3}(0.0, 0.0, 0.0)\npositions = [zero3, SVector{3}(1.1, 0.0, 0.0)]\nvelocities = [zero3, zero3]\nforces = [zero3, zero3]\nmasses = [1.0, 1.0]\nbox = CubicBox(10.0)\ntypes = [1, 1]\ntype_names = Dict(1 => :A)\ncons = DistanceConstraints([(1, 2)], [1.0]; tol = 1e-10, maxiter = 100)\nff = ForceField((Tether(0.2),))\nsys = System(positions, velocities, forces, masses, box, types, type_names;\n             forcefield = ff, specific_potentials = ())","category":"page"},{"location":"tutorials/constraints/#3.-Advance-with-SHAKE/RATTLE","page":"Tutorial 3 · Constraints in Practice","title":"3. Advance with SHAKE/RATTLE","text":"","category":"section"},{"location":"tutorials/constraints/","page":"Tutorial 3 · Constraints in Practice","title":"Tutorial 3 · Constraints in Practice","text":"The helper velocity_verlet_shake_rattle! performs a velocity-Verlet step and projects onto the constraint manifold each sub-step.","category":"page"},{"location":"tutorials/constraints/","page":"Tutorial 3 · Constraints in Practice","title":"Tutorial 3 · Constraints in Practice","text":"using LinearAlgebra\n\nforces_fn(R) = begin\n    _ = R  # system.positions already updated in-place\n    Verlet.Core.compute_all_forces!(sys)\n    sys.forces\nend\n\ndt = 0.01\nfor step in 1:200\n    velocity_verlet_shake_rattle!(sys, forces_fn, dt, cons)\nend\n\nround(norm(sys.positions[1] - sys.positions[2]), digits = 6)","category":"page"},{"location":"tutorials/constraints/","page":"Tutorial 3 · Constraints in Practice","title":"Tutorial 3 · Constraints in Practice","text":"The distance is now maintained at 1.0 (within tolerance) throughout the trajectory.","category":"page"},{"location":"tutorials/constraints/#4.-Monitoring-residuals","page":"Tutorial 3 · Constraints in Practice","title":"4. Monitoring residuals","text":"","category":"section"},{"location":"tutorials/constraints/","page":"Tutorial 3 · Constraints in Practice","title":"Tutorial 3 · Constraints in Practice","text":"constraint_residuals provides diagnostics for both positional and velocity violations—essential for validating convergence when you relax tolerances or increase the timestep.","category":"page"},{"location":"tutorials/constraints/","page":"Tutorial 3 · Constraints in Practice","title":"Tutorial 3 · Constraints in Practice","text":"Verlet.Constraints.constraint_residuals(sys, cons)","category":"page"},{"location":"tutorials/constraints/#Checklist-for-stable-constrained-runs","page":"Tutorial 3 · Constraints in Practice","title":"Checklist for stable constrained runs","text":"","category":"section"},{"location":"tutorials/constraints/","page":"Tutorial 3 · Constraints in Practice","title":"Tutorial 3 · Constraints in Practice","text":"Select a tight enough tolerance for your system; 1e-8–1e-10 is typical.\nIncrease maxiter if the residuals fail to drop below tol.\nPass the same cons object to any thermostats so velocities remain constraint-consistent after stochastic steps.\nUse degrees_of_freedom(sys; constraints=cons, remove_com=true) when computing temperatures.","category":"page"},{"location":"tutorials/constraints/","page":"Tutorial 3 · Constraints in Practice","title":"Tutorial 3 · Constraints in Practice","text":"Next, continue with Tutorial 4 · Thermostatted Dynamics to add a Langevin thermostat on top of constrained motion.","category":"page"}]
}
