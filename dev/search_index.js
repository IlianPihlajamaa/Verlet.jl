var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [\n    Verlet,\n    Verlet.Core,\n    Verlet.Potentials,\n    Verlet.Neighbors,\n    Verlet.Constraints,\n    Verlet.Thermostats\n]\nOrder = [:function, :type]","category":"page"},{"location":"api/#Verlet.Core","page":"API","title":"Verlet.Core","text":"Core module: fundamental types & utilities.\n\nData representation (current):   positions :: Vector{SVector{D,T}}   velocities :: Vector{SVector{D,T}}   forces(R) :: Vector{SVector{D,T}} (or (F,U) with return_potential=true)\n\nMatrix-based NxD layouts are deprecated.\n\n\n\n\n\n","category":"module"},{"location":"api/#Verlet.Core.CubicBox","page":"API","title":"Verlet.Core.CubicBox","text":"struct CubicBox{T<:Real}\n\nSimple cubic periodic box with side length L.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Core.ParticleSystem","page":"API","title":"Verlet.Core.ParticleSystem","text":"ParticleSystem{Dims,T_float}\n\nA lightweight container for particle states.\n\nFields\n\npositions::Vector{SVector{Dims,T_float}}: length-N vector of positions (each an SVector)\nvelocities::Vector{SVector{Dims,T_float}}: length-N vector of velocities\nmasses::Vector{T_float}: length-N vector of particle masses\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Core.kinetic_energy-Union{Tuple{ParticleSystem{Dims, T_float}}, Tuple{T_float}, Tuple{Dims}} where {Dims, T_float}","page":"API","title":"Verlet.Core.kinetic_energy","text":"kinetic_energy(system::ParticleSystem) -> T_float\n\nTotal kinetic energy: ∑ ½ mᵢ ‖vᵢ‖².\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.minimum_image-Tuple{AbstractVector, CubicBox}","page":"API","title":"Verlet.Core.minimum_image","text":"minimum_image(Δ, box::CubicBox)\nminimum_image(Δ, L)\n\nApply the minimum-image convention to the displacement vector Δ for the periodic box (wraps components to (-L/2, L/2]) and return the new vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.potential_energy-Union{Tuple{T_float}, Tuple{Dims}, Tuple{ParticleSystem{Dims, T_float}, Function}} where {Dims, T_float}","page":"API","title":"Verlet.Core.potential_energy","text":"potential_energy(system::ParticleSystem{Dims,T_float}, forces::Function) -> T_float\n\nTry to obtain total potential energy using forces(...; return_potential=true) convention.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.velocity_verlet!-Union{Tuple{T_float}, Tuple{Dims}, Tuple{ParticleSystem{Dims, T_float}, Function, T_float}} where {Dims, T_float}","page":"API","title":"Verlet.Core.velocity_verlet!","text":"velocity_verlet!(system::ParticleSystem{Dims,T_float}, forces::Function, dt::T_float)\n\nAdvance system by one timestep dt using the velocity Verlet integrator.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.wrap_positions!-Union{Tuple{T}, Tuple{Dims}, Tuple{Array{StaticArraysCore.SVector{Dims, T}, 1}, CubicBox}} where {Dims, T}","page":"API","title":"Verlet.Core.wrap_positions!","text":"wrap_positions!(R, box::CubicBox)\n\nWrap particle positions R into the primary periodic image of box in-place. This is useful before building neighbor lists or measuring displacements.\n\nThe resulting positions will be in the range (-L/2, L/2].\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.CellGrid","page":"API","title":"Verlet.Neighbors.CellGrid","text":"CellGrid{IT<:Integer, T<:Real}\n\nLinked-list cell grid for cubic periodic boxes. The domain is split into a uniform dims = (nx,ny,nz) grid of cubic cells with an intrusive linked list (heads, next) storing particle indices in each cell. This enables O(N) rebinning at fixed density and powers the O(N) neighbor build.\n\nFields\n\nL::T: cubic box length.\ncell_size::T: effective uniform cell width actually used for binning.\ndims::NTuple{3,IT}: number of cells along each axis (each ≥ 1).\nheads::Vector{IT}: length nx*ny*nz; head index per cell (0 sentinel = empty).\nnext::Vector{IT}: length N; linked list “next” pointer per particle (0 = end).\n\ntip: How `cell_size` is chosen\nbuild_cellgrid computes nx = floor(Int, L/cell_size) and then uses the effective width L/nx for indexing so that a 27-cell sweep is sufficient for a search radius ≤ cell_size.\n\nwarning: Units\nR and L must be expressed in the same length units.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Neighbors.NeighborList","page":"API","title":"Verlet.Neighbors.NeighborList","text":"NeighborList{IT<:Integer,T<:Real}\n\nCompressed-sparse-row (CSR) neighbor list with snapshot of reference positions.\n\nFields\n\ncutoff::T: physical cutoff distance (rcut).\nskin::T: extra buffer distance beyond cutoff.\npairs::Vector{IT}: concatenated neighbor indices (CSR-style).\noffsets::Vector{IT}: length N+1; neighbors of particle i are stored in pairs[offsets[i]:(offsets[i+1]-1)].\nref_positions::Matrix{T}: snapshot of positions at last rebuild, used for displacement checks.\n\nUse build_neighborlist to construct, and maybe_rebuild! to keep it updated.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Neighbors.build_cellgrid-Tuple{AbstractVector, Any}","page":"API","title":"Verlet.Neighbors.build_cellgrid","text":"build_cellgrid(R, box; cell_size)\n\nCreate a new CellGrid sized for cell_size and bin positions R (N×3). Returns a populated grid with linked lists set for particle indices 1..N.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.build_neighborlist-Union{Tuple{T}, Tuple{Dims}, Tuple{Array{StaticArraysCore.SVector{Dims, T}, 1}, CubicBox{T}}} where {Dims, T}","page":"API","title":"Verlet.Neighbors.build_neighborlist","text":"build_neighborlist(R, box; cutoff, skin=0.3) -> NeighborList\n\nConstruct a neighbor list for positions R inside a CubicBox. Pairs are included if they are within cutoff + skin under minimum-image distance.\n\nThis is an O(N²) operation but performed infrequently. The returned NeighborList uses a CSR (compressed sparse row) layout for compact storage and fast iteration.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.build_neighborlist_cells-Tuple{AbstractVector, Any}","page":"API","title":"Verlet.Neighbors.build_neighborlist_cells","text":"build_neighborlist_cells(R, box; cutoff, skin=0.3, grid=nothing) -> NeighborList-like\n\nConstruct a half neighbor list (each pair appears exactly once with j>i) using an O(N) cell-linked grid build. Returns an object with .offsets and .pairs fields compatible with typical CSR traversal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.lj_forces-Union{Tuple{IT}, Tuple{T}, Tuple{Dims}, Tuple{Array{StaticArraysCore.SVector{Dims, T}, 1}, CubicBox{T}, NeighborList{IT, T, Dims}}} where {Dims, T, IT}","page":"API","title":"Verlet.Neighbors.lj_forces","text":"lj_forces(R, box, nlist; ϵ=1.0, σ=1.0, rcut=NaN, shift=false, return_potential=false)\n\nCompute Lennard–Jones forces using a prebuilt NeighborList. This is more efficient than the brute-force O(N²) kernel, scaling ~O(N) for fixed density.\n\nArguments\n\nR::Vector{SVector{Dims,T}}: positions.\nbox::CubicBox: periodic cubic box.\nnlist::NeighborList: neighbor list built with at least the requested cutoff.\n\nKeywords\n\nϵ: LJ well depth (default 1.0).\nσ: LJ length scale (default 1.0).\nrcut: optional cutoff to use for the force calculation (defaults to nlist.cutoff).\nshift::Bool: if true, subtract potential at cutoff to make it continuous.\nreturn_potential::Bool: if true, also return total potential energy.\n\nReturns\n\nF::Vector{SVector{Dims,T}}: force on each particle (same shape as R).\nU::Float64 (if return_potential=true).\n\nExample\n\nbox = CubicBox(8.0)\nR = randn(SVector{3, Float64}, 10)\nwrap_positions!(R, box)\nnlist = build_neighborlist(R, box; cutoff=2.5, skin=0.4)\nF, U = lj_forces(R, box, nlist; rcut=2.5, return_potential=true)\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.maybe_rebuild!-Union{Tuple{Dims}, Tuple{T}, Tuple{IT}, Tuple{NeighborList{IT, T, Dims}, Array{StaticArraysCore.SVector{Dims, T}, 1}, CubicBox{T}}} where {IT, T, Dims}","page":"API","title":"Verlet.Neighbors.maybe_rebuild!","text":"maybe_rebuild!(nlist, R, box) -> Bool\n\nCheck whether the neighbor list nlist is still valid given new positions R. If the maximum displacement since the last build is greater than skin/2, rebuild the list and return true. Otherwise leave it unchanged and return false.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.rebin!-Union{Tuple{T}, Tuple{IT}, Tuple{Verlet.Neighbors.CellGrid{IT, T}, AbstractVector, Any}} where {IT<:Integer, T<:Real}","page":"API","title":"Verlet.Neighbors.rebin!","text":"rebin!(grid, R, box) -> grid\n\nReset the grid's heads and next and bin the positions R into cells according to the current cell_size and periodic cubic box box.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.DistanceConstraints","page":"API","title":"Verlet.Constraints.DistanceConstraints","text":"struct DistanceConstraints{T_int,T_float}\n\nImmutable set of pairwise distance constraints for SHAKE/RATTLE.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Constraints.apply_rattle!-Tuple{Any, DistanceConstraints}","page":"API","title":"Verlet.Constraints.apply_rattle!","text":"apply_rattle!(ps, cons)\n\nCorrect velocities to satisfy velocity constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.apply_shake!-Tuple{Any, DistanceConstraints, Any}","page":"API","title":"Verlet.Constraints.apply_shake!","text":"apply_shake!(ps, cons, dt)\n\nIteratively correct positions to satisfy constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.constraint_residuals-Tuple{Any, DistanceConstraints}","page":"API","title":"Verlet.Constraints.constraint_residuals","text":"constraint_residuals(ps::ParticleSystem, cons::DistanceConstraints) -> (; maxC, rmsC, maxCd, rmsCd)\n\nCompute the constraint residuals for a system subject to pairwise distance constraints.\n\nFor each constraint l with atoms (i, j) and target distance r0_l:\n\nPosition residual: C_l = ||r_i - r_j||^2 - r0_l^2\nVelocity residual: Ċ_l = 2 (r_i - r_j) ⋅ (v_i - v_j)\n\nReturns a named tuple with maxC, rmsC, maxCd, rmsCd.\n\nExample\n\nps = ParticleSystem([SVector(0.0, 0, 0), SVector(1.0, 0, 0)], [SVector(0.0, 0, 0), SVector(0.0, 0, 0)], [1.0, 1.0])\ncons = DistanceConstraints([(1,2)], [1.0])\nconstraint_residuals(ps, cons)\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.remove_com_motion!-Tuple{Any}","page":"API","title":"Verlet.Constraints.remove_com_motion!","text":"remove_com_motion!(ps; which=:velocity)\n\nRemove center-of-mass motion from velocities/positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.velocity_verlet_shake_rattle!-Tuple{Any, Any, Any, DistanceConstraints}","page":"API","title":"Verlet.Constraints.velocity_verlet_shake_rattle!","text":"velocity_verlet_shake_rattle!(ps, forces, dt, cons)\n\nConstrained velocity Verlet step with SHAKE/RATTLE.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.degrees_of_freedom","page":"API","title":"Verlet.Thermostats.degrees_of_freedom","text":"degreesoffreedom(ps) -> Int\n\n\nReturn the effective translational degrees of freedom of the system. Currently this is simply N * D for N particles in D spatial dimensions.\n\nThis function is a hook for future extensions (e.g., constraints, rigid bodies, or COM removal) that reduce the effective DoF used in temperature calculations.\n\n\n\n\n\n","category":"function"},{"location":"api/#Verlet.Thermostats.degrees_of_freedom-Tuple{Any}","page":"API","title":"Verlet.Thermostats.degrees_of_freedom","text":"degrees_of_freedom(ps; constraints=nothing, remove_com=false) -> Int\n\nEffective translational DoF, reduced by number of constraints and optionally COM removal. This is the canonical method. A no-keyword fallback is provided for backward compatibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.instantaneous_temperature","page":"API","title":"Verlet.Thermostats.instantaneous_temperature","text":"instantaneous_temperature(ps; kB=1.0) -> Float64\n\n\nCompute the instantaneous scalar temperature via equipartition:\n\nKE = 0.5 * Σᵢ mᵢ ||vᵢ||² T  = 2 * KE / (kB * dof)\n\nwhere dof = degrees_of_freedom(ps). For now, dof = N * D (translational DoF only).\n\nKeywords\n\nkB::Real = 1.0: Boltzmann constant in your unit system.\n\nReturns\n\nFloat64: instantaneous temperature.\n\nNotes\n\nFor small N, expect large fluctuations. Compare time averages to the target T when thermostatting.\n\n\n\n\n\n","category":"function"},{"location":"api/#Verlet.Thermostats.instantaneous_temperature-Union{Tuple{Any}, Tuple{T_float}} where T_float","page":"API","title":"Verlet.Thermostats.instantaneous_temperature","text":"instantaneous_temperature(ps; kB=1.0) -> Float64\n\nCompute instantaneous temperature via equipartition: T = 2 * KE / (kB * dof).\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.langevin_baoab!","page":"API","title":"Verlet.Thermostats.langevin_baoab!","text":"langevinbaoab!(ps::ParticleSystem, forces, dt; γ, T, kB=1.0, rng=Random.defaultrng())\n\n\nAdvance the system by one NVT step using the Langevin BAOAB integrator.\n\nThis scheme integrates the Langevin SDE\n\nm dv = [F(r) - γ m v] dt + √(2γ m kB T) dW,     dr = v dt\n\nvia the B → A → O → A → B splitting with an exact Ornstein–Uhlenbeck (O) step. It is widely used for robust thermostatting and near-optimal configurational sampling. When γ == 0, the O-step is the identity and BAOAB reduces to velocity–Verlet (up to roundoff).\n\nArguments\n\nps::ParticleSystem: System with positions::Vector{SVector{Dims,T}}, velocities::Vector{SVector{Dims,T}}, and masses::Vector{T}.\nforces: A callable F(R)::Vector{SVector{Dims,T}} returning forces evaluated at positions R.\ndt::Real: Time step (same time units as used for γ).\n\nKeywords\n\nγ::Real: Friction coefficient [1/time].\nT::Real: Target temperature. Must be consistent with kB (so that kB*T has units of energy).\nkB::Real = 1.0: Boltzmann constant in your unit system.\nrng::AbstractRNG = Random.default_rng(): RNG used only in the stochastic O-step for reproducibility.\n\nDetails\n\nThe O-step uses the exact OU update: c = exp(-γ*dt) sᵢ = sqrt((1 - c^2) * kB*T / mᵢ)  # per-particle, per-component scale vᵢ[k] ← c * vᵢ[k] + sᵢ * ξ,    where ξ ~ 𝒩(0,1) For numerical stability when γ*dt ≪ 1, implementations should use the linearized forms c ≈ 1 - γ*dt and 1 - c^2 ≈ 2γ*dt to avoid catastrophic cancellation.\n\nPerformance tips\n\nAvoid allocations in the inner loop. Reuse force buffers if you add multi-step drivers.\nUse @views for in-place operations on ps.positions/ps.velocities.\nPass an explicit rng to ensure reproducibility across runs and Julia sessions.\n\nPitfalls\n\nUnits matter: ensure γ is in 1/time, and kB*T is in energy, consistent with r, v, and m.\nVery large γ*dt yields overdamped dynamics (OK for sampling, not for kinetics).\nWith heterogeneous masses, compute sᵢ per particle; do not share a single scale across species.\nFor tiny systems, instantaneous temperature fluctuates strongly — average over time for diagnostics.\n\nExample\n\n```julia\n\nPseudocode showing typical usage (assumes your package exports ParticleSystem and BAOAB):\n\nusing Random N, D = 64, 3 ps = ParticleSystem(zeros(N, D), randn(N, D), ones(N)) dt, γ, T = 0.005, 1.0, 1.5 rng = MersenneTwister(123) forces(R) = -0.1 .* R  # harmonic \"bath\"\n\nfor _ in 1:2_000\n\nlangevin_baoab!(ps, forces, dt; γ=γ, T=T, kB=1.0, rng=rng) end ```\n\n\n\n\n\n","category":"function"},{"location":"api/#Verlet.Thermostats.langevin_baoab!-Tuple{Any, Any, Any}","page":"API","title":"Verlet.Thermostats.langevin_baoab!","text":"langevin_baoab!(ps, forces, dt; γ, T, kB=1.0, rng=Random.default_rng())\n\nAdvance one step with the Langevin BAOAB integrator: B(half) → A(half) → O(OU) → A(half) → B(half). With γ=0, this reduces to velocity-Verlet (deterministic).\n\nArguments\n\nps     : particle system (positions N×D, velocities N×D, masses length N)\nforces : callable F = forces(positions)::N×D\ndt     : time step\n\nKeywords\n\nγ  : friction (1/time)\nT  : target temperature\nkB : Boltzmann constant (default 1.0)\nrng: AbstractRNG for reproducibility\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.langevin_baoab_constrained!-Tuple{ParticleSystem, Any, Any, DistanceConstraints}","page":"API","title":"Verlet.Thermostats.langevin_baoab_constrained!","text":"langevin_baoab_constrained!(ps::ParticleSystem, forces, dt, cons::DistanceConstraints;\n                            γ, T, kB=1.0, rng=Random.default_rng())\n\nAdvance one constrained NVT BAOAB step with SHAKE/RATTLE projections.\n\nSplitting and projections:\n\nB (half kick)         → apply_rattle! (velocities)\nA (half drift)        → apply_shake! (positions)\nO (OU stochastic)     → apply_rattle! (velocities)\nA (half drift)        → apply_shake! (positions)\nRecompute forces\nB (half kick)         → apply_rattle! (velocities)\n\nNotes:\n\nUses exp(-γ*dt) for the OU decay. Noise variance is (1 - c^2) * kB*T / m_i per component.\nWith constraints, prefer this method over the unconstrained langevin_baoab!.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.velocity_rescale!","page":"API","title":"Verlet.Thermostats.velocity_rescale!","text":"velocity_rescale!(ps, T; kB=1.0)\n\n\nDeterministically rescale all velocities to match a target temperature T. This is a one-shot utility often used for quick pre-equilibration or initializing an NVT run. It is not a thermostat and does not generate the correct kinetic energy distribution by itself.\n\nKeywords\n\nkB::Real = 1.0: Boltzmann constant.\n\nNotes\n\nLet T₀ = instantaneous_temperature(ps; kB) and λ = √(T / max(T₀, eps())). This function applies vᵢ ← λ * vᵢ in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/#Verlet.Thermostats.velocity_rescale!-Tuple{Any, Real}","page":"API","title":"Verlet.Thermostats.velocity_rescale!","text":"velocity_rescale!(ps, T; kB=1.0)\n\nDeterministically rescale velocities to match target temperature T.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Molecular systems often contain rigid bonds or fixed distances between atoms. These are represented using the DistanceConstraints type and enforced using SHAKE (positions) and RATTLE (velocities).","category":"page"},{"location":"constraints/#Residual-Monitoring","page":"Constraints","title":"Residual Monitoring","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The helper function constraint_residuals reports how well constraints are satisfied at a given state:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"maxC, rmsC — maximum and RMS positional residuals\nmaxCd, rmsCd — maximum and RMS velocity residuals","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"using Verlet, StaticArrays\npositions = [SVector{3}(0.0, 0.0, 0.0), SVector{3}(1.0, 0.0, 0.0)]\nvelocities = [SVector{3}(0.0, 0.0, 0.0) for _ in 1:2]\nmasses = ones(2)\nps = ParticleSystem(positions, velocities, masses)\ncons = DistanceConstraints([(1,2)], [1.0])\nconstraint_residuals(ps, cons)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"These values are useful for debugging and regression testing.","category":"page"},{"location":"constraints/#Usage-with-cBAOAB","page":"Constraints","title":"Usage with cBAOAB","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"When running constrained Langevin dynamics with langevin_baoab_constrained!, residuals should remain close to machine precision (typically 1e-8 or smaller) if the solver tolerance is sufficiently strict.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"See also:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"apply_shake!\napply_rattle!\nlangevin_baoab_constrained!","category":"page"},{"location":"guide/numerics/#NVT-(Langevin-BAOAB)-Thermostat","page":"Numerical Notes","title":"NVT (Langevin BAOAB) Thermostat","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"This guide shows how to run constant-temperature (NVT) dynamics using the Langevin BAOAB integrator and how to monitor/adjust the system temperature with a few convenience tools.","category":"page"},{"location":"guide/numerics/#Why-BAOAB?","page":"Numerical Notes","title":"Why BAOAB?","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Excellent configurational sampling compared to naive Euler–Maruyama.\nRobust for larger dt at a given target T.\nExact Ornstein–Uhlenbeck (OU) substep and only one force evaluation per step.\nWith γ = 0, BAOAB reduces to velocity–Verlet.","category":"page"},{"location":"guide/numerics/#Quick-Start","page":"Numerical Notes","title":"Quick Start","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"# Typical workflow (package API names shown; adapt to your module's name/exports)\nusing Random, StaticArrays\n\nN, D = 64, 3\npositions = [@SVector zeros(D) for _ in 1:N]\nvelocities = [@SVector randn(D) for _ in 1:N]\nmasses = ones(N)\nps = ParticleSystem(positions, velocities, masses)\nforces(R) = [ -0.2 .* r for r in R ]  # any user-defined force function\ndt = 0.005      # time step\nγ  = 1.0        # friction [1/time]\nTt = 1.5        # target T  (kB=1.0 here, so T is in energy units)\nrng = MersenneTwister(2025)\n\n# Optional: bring KE near the target quickly\nvelocity_rescale!(ps, Tt; kB=1.0)\n# Run several steps under NVT\nfor _ in 1:2_000\n\tlangevin_baoab!(ps, forces, dt; γ=γ, T=Tt, kB=1.0, rng=rng)\nend\n\n@info \"Instantaneous T\" instantaneous_temperature(ps; kB=1.0)","category":"page"},{"location":"guide/numerics/#Choosing-γ-and-dt","page":"Numerical Notes","title":"Choosing γ and dt +","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Units: ensure γ is in 1/time and kB*T in energy, consistent with r, v, and m.\nStart with γ*dt ≈ 0.1–1. Larger values overdamp dynamics (OK for sampling; poor for kinetics).\nKeep dt similar to your velocity–Verlet choice at the same force field. BAOAB is often at least as stable. +","category":"page"},{"location":"guide/numerics/#Algorithm-Sketch","page":"Numerical Notes","title":"Algorithm Sketch +","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"BAOAB splits each step into B (half kick) → A (half drift) → O (OU) → A → B. The OU substep uses the exact update v ← c*v + s*ξ with c = exp(-γ*dt) and s = √((1 - c^2) * kB*T / m). See the function docstring for further details, including numerics for small γ*dt. +","category":"page"},{"location":"guide/numerics/#Diagnostics","page":"Numerical Notes","title":"Diagnostics +","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"instantaneous_temperature(ps; kB) returns the current kinetic temperature using equipartition (dof = N*D for now).\nTime-average instantaneous_temperature over many steps (or save to disk) to validate the thermostat. +","category":"page"},{"location":"guide/numerics/#Pitfalls-and-Tips","page":"Numerical Notes","title":"Pitfalls & Tips +","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Mass heterogeneity: compute OU noise per particle using its mass; do not reuse a single scale across species.\nSmall systems: temperature fluctuates strongly; judge convergence statistically.\nReproducibility: always pass an explicit RNG into langevin_baoab!.\nNot a thermostat: velocity_rescale! is useful for a single \"KE nudge\" but does not produce the correct canonical distribution. +","category":"page"},{"location":"guide/numerics/#API-Reference","page":"Numerical Notes","title":"API Reference","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"@docs langevin_baoab! instantaneous_temperature degrees_of_freedom velocity_rescale!","category":"page"},{"location":"guide/numerics/#Timestep-stability","page":"Numerical Notes","title":"Timestep stability","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Velocity Verlet is symplectic and stable for sufficiently small dt.\nIf you see exploding energies or trajectories, reduce dt.\nStart with a small dt (e.g. 1e-3 in your time units) and increase cautiously.","category":"page"},{"location":"guide/numerics/#Precision","page":"Numerical Notes","title":"Precision","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Use Float64 across positions, velocities, and masses to limit drift. Distances, forces, and energies are accumulated in Float64 by default.","category":"page"},{"location":"guide/numerics/#Shapes-and-broadcasting","page":"Numerical Notes","title":"Shapes & broadcasting","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Positions, velocities, and forces are now Vector{SVector{D, T}} with one SVector per particle.\nmasses is length N. To divide forces by mass, use broadcasting: [F[i] ./ masses[i] for i in 1:length(F)].","category":"page"},{"location":"guide/numerics/#Note-on-Particle-Representation","page":"Numerical Notes","title":"Note on Particle Representation","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"All positions, velocities, and forces are now represented as Vector{SVector{D, T}} for performance and type stability. Update your code and force functions accordingly.","category":"page"},{"location":"guide/numerics/#Boundary-conditions-(not-included)","page":"Numerical Notes","title":"Boundary conditions (not included)","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"No periodic or reflective boundaries are included. Implement them in your force or position update logic if needed.","category":"page"},{"location":"guide/numerics/#Potential-energy-protocol","page":"Numerical Notes","title":"Potential energy protocol","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Provide forces(r; return_potential=true) => (F, U) to enable potential_energy.\nIf unknown, prefer returning only F and skip potential-energy reporting.","category":"page"},{"location":"guide/numerics/#Units","page":"Numerical Notes","title":"Units","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"All quantities are unitless arrays but must be consistent (e.g., LJ with σ=1).","category":"page"},{"location":"guide/numerics/#Periodic-boundaries","page":"Numerical Notes","title":"Periodic boundaries","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Use wrap_positions! after moving particles.\nThe minimum-image convention is implemented by minimum_image!.","category":"page"},{"location":"guide/numerics/#Neighbor-list-rebuild-policy","page":"Numerical Notes","title":"Neighbor list rebuild policy","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"maybe_rebuild! triggers a rebuild when the maximum displacement since the last build exceeds skin/2. With the cell-linked builder, rebuilds are O(N).","category":"page"},{"location":"guide/numerics/#Box-size-and-geometry","page":"Numerical Notes","title":"Box size and geometry","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Ensure L > 2*(cutoff + skin) to avoid ambiguous minimum-image shells.","category":"page"},{"location":"guide/forces/#Forces-and-Potentials","page":"Forces & Potentials","title":"Forces & Potentials","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"using StaticArrays\n# Free particle (no forces)\nforces_free(R) = [@SVector zeros(length(R[1])) for _ in R]\n\n# Linear spring to the origin (Hooke's law, k = 1)\nforces_ho(R) = [ -r for r in R ]\n\n# With potential-energy support:\nfunction forces_ho_with_U(R; return_potential=false)\n    F = [ -r for r in R ]\n    U = 0.5 * sum(norm(r)^2 for r in R)\n    return return_potential ? (F, U) : F\nend\nnothing\n# Forces & Potentials","category":"page"},{"location":"guide/forces/#Lennard–Jones-with/without-Neighbor-Lists","page":"Forces & Potentials","title":"Lennard–Jones with/without Neighbor Lists","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"using Verlet, StaticArrays, LinearAlgebra\n\nbox = CubicBox(10.0)\nR = [@SVector(randn(3)) for _ in 1:64]; wrap_positions!(R, box)\n# Brute force (O(N²))\nF_bf, U_bf = lj_forces(R, box; rcut=2.5, return_potential=true)\n# Classic symmetric neighbor list (O(N) per step, O(N²) build)\nnlsym = build_neighborlist(R, box; cutoff=2.5, skin=0.4)\nF_sym, U_sym = lj_forces(R, box, nlsym; rcut=2.5, return_potential=true)\n# Cell-based half neighbor list (O(N) build, O(N) per step)\ngrid = build_cellgrid(R, box; cell_size=2.9)\nnlhalf = build_neighborlist_cells(R, box; cutoff=2.5, skin=0.4, grid=grid)\nF_half, U_half = lj_forces(R, box, nlhalf; rcut=2.5, return_potential=true)\nerr_sym = sum(norm(F_bf[i] - F_sym[i]) for i in eachindex(F_sym))\nerr_half = sum(norm(F_bf[i] - F_half[i]) for i in eachindex(F_half)) \n(err_sym, err_half)","category":"page"},{"location":"guide/forces/#Custom-forces-with-potential","page":"Forces & Potentials","title":"Custom forces with potential","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"To make potential_energy work, return (F, U) when the keyword return_potential=true is provided:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"using Verlet, StaticArrays, LinearAlgebra\nfunction ho_forces(R; return_potential=false)\n    F = [ -r for r in R ]      # k = 1\n    U = 0.5 * sum(norm(r)^2 for r in R)\n    return return_potential ? (F, U) : F\nend\npositions = [@SVector [1.0, 0.0]]\nvelocities = [@SVector [0.0, 0.0]]\nmasses = [1.0]\nps = ParticleSystem(positions, velocities, masses)\nE = potential_energy(ps, ho_forces)\nE","category":"page"},{"location":"guide/forces/#Performance-notes","page":"Forces & Potentials","title":"Performance notes","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"Prefer half lists for LJ when possible; they reduce memory and branches.\nWith O(N) builds, you can lower skin (e.g., 0.2–0.3) for tighter forces.\nUse Vector{SVector} for all positions, velocities, and forces for best performance.","category":"page"},{"location":"#Verlet.jl","page":"Home","title":"Verlet.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A minimal velocity Verlet integrator for tiny MD-style problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nYou choose the units; just keep them consistent across positions r, velocities v, masses m, forces F, and timestep dt.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Verlet, StaticArrays\n\n# Free particle in 2D\npositions = [@SVector [0.0, 0.0]]\nvelocities = [@SVector [1.0, 0.0]]\nmasses = [1.0]\nforces(R) = [@SVector zeros(2) for _ in R]\n\nps = ParticleSystem(positions, velocities, masses)\n\ndt = 0.1\nvelocity_verlet!(ps, forces, dt)\nps.positions","category":"page"},{"location":"#Next-Steps","page":"Home","title":"Next Steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check out the [Guide → Constrained Dynamics](@ref constraints-guide) section to learn how to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Set up bond constraints with DistanceConstraints\nRun constrained dynamics with velocity_verlet_shake_rattle!","category":"page"},{"location":"#Harmonic-oscillator","page":"Home","title":"Harmonic oscillator","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Verlet, StaticArrays, LinearAlgebra\n\n# Hooke's law with k = 1, potential U = 0.5 * |r|^2\nfunction ho_forces(R; return_potential=false)\n    F = [-r for r in R]\n    U = 0.5 * sum(norm(r)^2 for r in R)\n    return return_potential ? (F, U) : F\nend\n\npositions = [@SVector [1.0, 0.0]]\nvelocities = [@SVector [0.0, 0.0]]\nmasses = [1.0]\nps = ParticleSystem(positions, velocities, masses)\n\ndt = 0.1\nfor _ in 1:100\n    velocity_verlet!(ps, ho_forces, dt)\nend\n\n(kin = kinetic_energy(ps), pot = potential_energy(ps, ho_forces))","category":"page"},{"location":"#Energy-monitoring","page":"Home","title":"Energy monitoring","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Verlet, StaticArrays, LinearAlgebra\n\nfunction ho_forces(R; return_potential=false)\n    F = [-r for r in R]\n    U = 0.5 * sum(norm(r)^2 for r in R)\n    return return_potential ? (F, U) : F\nend\n\npositions = [@SVector [1.0, 0.0]]\nvelocities = [@SVector [0.0, 1.0]]\nmasses = [1.0]\nps = ParticleSystem(positions, velocities, masses)\ndt = 0.05\n\nenergies = Float64[]\nfor _ in 1:200\n    velocity_verlet!(ps, ho_forces, dt)\n    push!(energies, kinetic_energy(ps) + potential_energy(ps, ho_forces))\nend\n\n(round(minimum(energies), digits=6), round(maximum(energies), digits=6))","category":"page"},{"location":"#Performance-tips","page":"Home","title":"Performance tips","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Keep arrays as Matrix{Float64} / Vector{Float64} to avoid type instability.\nPrefer in-place force computations in your own code paths; if you must allocate, reuse buffers.\nAvoid huge dt. Start small (e.g., 1e-3 in your time units) and increase cautiously.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also: [Numerics & Pitfalls](@ref numerics).","category":"page"},{"location":"","page":"Home","title":"Home","text":"With constraints, you can simulate rigid bonds (e.g. water models) and safely increase timestep sizes while preserving stability.","category":"page"},{"location":"#Speeding-up-LJ-with-a-Neighbor-List","page":"Home","title":"Speeding up LJ with a Neighbor List","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The naive Lennard–Jones force kernel scales as O(N²), which quickly becomes expensive as the number of particles grows. A Verlet neighbor list reduces this to O(N) on average at fixed density by storing nearby pairs and updating them only occasionally.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Verlet\n\n# Create a cubic periodic box\nbox = CubicBox(20.0)\n\nusing StaticArrays\n# Random positions for 100 particles in 3D as SVectors\nR = [@SVector randn(3) for _ in 1:100]\nwrap_positions!(R, box)\n\n# Build neighbor list with cutoff + skin\nnlist = build_neighborlist(R, box; cutoff=2.5, skin=0.4)\n\n# Rebuild when particles have moved far enough\nmaybe_rebuild!(nlist, R, box) && @info \"Neighbor list rebuilt\"\n\n# Compute forces using the list-aware kernel\nF, U = lj_forces(R, box, nlist; rcut=2.5, return_potential=true)\n@show size(F), U","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the full API reference in api.md.","category":"page"},{"location":"#Note-on-Particle-Representation","page":"Home","title":"Note on Particle Representation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Verlet.jl now uses Vector{SVector{Dims, T_Float}} (from StaticArrays) to represent particle positions, velocities, displacements, and forces. This provides better performance and type stability compared to the previous Matrix-based approach. All user code and force functions should now expect and return vectors of SVectors, e.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Verlet, StaticArrays\nN, D = 100, 3\npositions = [@SVector randn(D) for _ in 1:N]\nvelocities = [@SVector zeros(D) for _ in 1:N]\nmasses = ones(N)\nps = ParticleSystem(positions, velocities, masses)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Force functions should accept and return Vector{SVector} as well:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function my_forces(R)\n    # R is Vector{SVector{D, T}}\n    return [@SVector zeros(length(R[1])) for _ in R]\nend","category":"page"},{"location":"#NEW:-O(N)-Build-with-Cell-Linked-Lists-Half-Neighbor-Lists","page":"Home","title":"NEW: O(N) Build with Cell-Linked Lists + Half Neighbor Lists","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The classic build_neighborlist uses an O(N²) construction. For larger systems you can switch to a cell-linked grid builder that is O(N) at fixed density and emits a half list (each pair stored once with j > i):","category":"page"},{"location":"","page":"Home","title":"Home","text":"D = 3\nbox = CubicBox(10.0)\ncutoff, skin = 2.5, 0.4\nR = [SVector{D}((rand(D) .- 0.5) .* box.L) for _ in 1:2_000]  # random positions in (-L/2, L/2]\nwrap_positions!(R, box)\ngrid = build_cellgrid(R, box; cell_size=cutoff+skin)\nnl = build_neighborlist_cells(R, box; cutoff=cutoff, skin=skin, grid=grid)\n# Force evaluation with half list (branch-free inner loop)\nF = lj_forces(R, box, nl; rcut=cutoff)  # or (F,U) with return_potential=true\nsize(F)","category":"page"},{"location":"#Why-half-lists?","page":"Home","title":"Why half lists?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"* Less memory: store each pair once (≈½ the entries of a symmetric list). * Fewer branches: kernel no longer checks j > i at runtime. * Same physics: forces are accumulated for both i and j when a pair is visited.","category":"page"},{"location":"#Rebuild-policy","page":"Home","title":"Rebuild policy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Use the same half-skin rule via maybe_rebuild!. With O(N) builds you can afford a smaller skin (e.g., 0.2–0.3) to reduce neighbor count and tighten force errors:","category":"page"},{"location":"","page":"Home","title":"Home","text":"box = CubicBox(15.0)\nR = randn(SVector{3, Float64}, 500); wrap_positions!(R, box)\ncutoff, skin = 2.5, 0.3\ngrid = build_cellgrid(R, box; cell_size=cutoff+skin)\nnl = build_neighborlist_cells(R, box; cutoff=cutoff, skin=skin, grid=grid)\n\n# ... advance dynamics updating R ...\n\nif maybe_rebuild!(nl, R, box)\n    rebin!(grid, R, box) # O(N)\n    nl = build_neighborlist_cells(R, box; cutoff=cutoff, skin=skin, grid=grid)\nend","category":"page"},{"location":"#Pitfalls","page":"Home","title":"Pitfalls","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"* Box too small: ensure L > 2*(cutoff + skin) so minimum-image distances are unambiguous. * Cell size semantics: the grid uses an effective width L/nx ≥ cutoff+skin. * Units: R/L must share the same units; cutoff/skin are in those units. * Precision: distance math uses Float64. Mixed-precision inputs are converted.","category":"page"},{"location":"#Performance-Tips","page":"Home","title":"Performance Tips","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Choose a skin large enough that rebuilds are infrequent, but not so large that each particle has too many neighbors.     A good starting point is skin ≈ 0.3σ.\nEnsure the box length L satisfies L > 2*(cutoff + skin) to avoid ambiguous minimum-image distances.\nAccumulated forces and energies are stored in Float64 for stability even if input positions are Float32.\nRebuilds are O(N²), but are triggered rarely. Per-step force computation with the neighbor list is O(N) on average.","category":"page"},{"location":"#Common-Pitfalls","page":"Home","title":"Common Pitfalls","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using a too small skin can cause missed interactions if particles move across the buffer before a rebuild.\nForgetting to call wrap_positions! regularly may lead to large apparent displacements across periodic boundaries.\nThe neighbor list includes symmetric neighbors. Forces should only be applied once per pair (the built-in lj_forces handles this).","category":"page"},{"location":"#See-Also","page":"Home","title":"See Also","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"build_neighborlist — construct a new list from positions.  \nmaybe_rebuild! — keep a list up-to-date based on displacements.  \nwrap_positions! — enforce periodic wrapping of coordinates.  \nlj_forces — compute Lennard–Jones forces with or without a neighbor list.","category":"page"},{"location":"#Further-Notes","page":"Home","title":"Further Notes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Constraints — how SHAKE/RATTLE are applied and how to monitor residuals\nNumerical Notes — guidance on tolerances, thermostat interaction, and reproducibility","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"constraints.md\", \"numerics.md\", \"api.md\"]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"api.md\"]","category":"page"},{"location":"numerics/#Numerical-Notes","page":"Numerical Notes","title":"Numerical Notes","text":"","category":"section"},{"location":"numerics/#Constraint-Tolerances-and-Thermostat-Parameters","page":"Numerical Notes","title":"Constraint Tolerances and Thermostat Parameters","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"When using langevin_baoab_constrained!, the SHAKE and RATTLE solvers enforce distance constraints up to the tolerance specified in DistanceConstraints.","category":"page"},{"location":"numerics/#Interplay-with-γ-and-T","page":"Numerical Notes","title":"Interplay with γ and T","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Larger friction γ and higher temperature T produce stronger stochastic kicks in the OU step.\nThis may increase the number of iterations needed for constraint convergence.\nIf the solver fails to converge within maxiter, consider relaxing tol slightly.","category":"page"},{"location":"numerics/#Mass-Variance","page":"Numerical Notes","title":"Mass Variance","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Constraints involving very light particles (e.g. hydrogens) can converge more slowly if highly coupled with heavier atoms. This is expected and usually acceptable for simple bond constraints.","category":"page"},{"location":"numerics/#Degrees-of-Freedom-and-Temperature","page":"Numerical Notes","title":"Degrees of Freedom and Temperature","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"The function instantaneous_temperature uses the full degrees of freedom by default. For constrained systems, users who want diagnostics consistent with statistical mechanics should instead call:","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"degrees_of_freedom(ps; constraints=cons, remove_com=false)","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"and use this value in temperature calculations.","category":"page"},{"location":"numerics/#Reproducibility","page":"Numerical Notes","title":"Reproducibility","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"The stochastic step uses the provided RNG. Set a fixed seed (e.g. rng = MersenneTwister(1234)) in tests or benchmarks for reproducibility.","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"See also: constraint_residuals for monitoring how well constraints are satisfied.","category":"page"},{"location":"guide/constraints/#Constrained-Dynamics-(SHAKE/RATTLE)","page":"Constrained Dynamics","title":"Constrained Dynamics (SHAKE/RATTLE)","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"@id constraints-guide","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Molecular simulations often require certain bond lengths (e.g. X–H bonds in water) to remain fixed. This enables larger stable timesteps and enforces realistic rigid-body structures.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Verlet.jl provides support for holonomic distance constraints using the classical SHAKE (positions) and RATTLE (velocities) algorithms.","category":"page"},{"location":"guide/constraints/#Defining-Constraints","page":"Constrained Dynamics","title":"Defining Constraints","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Use DistanceConstraints to define a set of pairwise distance constraints:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using Verlet, StaticArrays\n# A diatomic molecule with target bond length 1.0\npairs   = [(1,2)]\nlengths = [1.0]\ncons = DistanceConstraints(pairs, lengths; tol=1e-10, maxiter=100)","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Arguments:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"pairs: vector of (i,j) atom index pairs (1-based)\nlengths: vector of target distances\ntol: maximum squared violation tolerated (|C_l| units length²)\nmaxiter: maximum SHAKE/RATTLE iterations per step\nuse_minimum_image: apply minimum image convention under periodic boundaries","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"tip: Tip\nFor constraints across periodic boundaries, keep molecules whole and use use_minimum_image=true.","category":"page"},{"location":"guide/constraints/#Constrained-Integrator","page":"Constrained Dynamics","title":"Constrained Integrator","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"The velocity_verlet_shake_rattle! driver advances the system with constraints enforced:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using Verlet, StaticArrays, LinearAlgebra\nN, D = 2, 3\npositions = [@SVector zeros(D) for _ in 1:N]\npositions[2] = @SVector [1.2, 0.0, 0.0]   # initial bond slightly off\nvelocities = [@SVector zeros(D) for _ in 1:N]\nmasses = ones(N)\nps = ParticleSystem(positions, velocities, masses)\ncons = DistanceConstraints([(1,2)], [1.0])\nforces(R) = [@SVector zeros(D) for _ in R]  # no external forces\nfor step in 1:100\n  velocity_verlet_shake_rattle!(ps, forces, 0.01, cons)\nend\nd = ps.positions[1] - ps.positions[2]\n@show norm(d)  # ~1.0","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"This integrator:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Updates velocities (half step) and positions (drift).\nApplies SHAKE projection to enforce bond lengths.\nRecomputes forces.\nCompletes velocity update.\nApplies RATTLE projection to enforce velocity constraints.","category":"page"},{"location":"guide/constraints/#Degrees-of-Freedom","page":"Constrained Dynamics","title":"Degrees of Freedom","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Constraints reduce the effective number of degrees of freedom (DoF). The degrees_of_freedom function accounts for:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"number of atoms × dimensions\nminus one per constraint\nminus dimensions if COM motion is removed","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using StaticArrays\nN, D = 3, 3\npositions = [@SVector zeros(D) for _ in 1:N]\nvelocities = [@SVector zeros(D) for _ in 1:N]\nmasses = ones(N)\nps = ParticleSystem(positions, velocities, masses)\ncons = DistanceConstraints([(1,2)], [1.0])\ndof = degrees_of_freedom(ps; constraints=cons, remove_com=true)\n@show dof","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Correct DoF is essential for unbiased temperature and pressure estimators.","category":"page"},{"location":"guide/constraints/#Removing-Center-of-Mass-Motion","page":"Constrained Dynamics","title":"Removing Center-of-Mass Motion","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Use remove_com_motion! to zero the mass-weighted center-of-mass velocity or position. This prevents unphysical drift of the entire system.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using StaticArrays\nN, D = 3, 3\npositions = [@SVector zeros(D) for _ in 1:N]\nvelocities = [@SVector ones(D) for _ in 1:N]\nmasses = [1.0, 2.0, 3.0]\nps = ParticleSystem(positions, velocities, masses)\nremove_com_motion!(ps; which=:velocity)\n# After removal, COM velocity should be ~0\nVcom = sum(ps.masses .* map(v -> v[1], ps.velocities)) / sum(ps.masses)\n@show Vcom","category":"page"},{"location":"guide/constraints/#Performance-Notes","page":"Constrained Dynamics","title":"Performance Notes","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"SHAKE/RATTLE typically converge in a few iterations for tree-like molecules.\nFor rings or stiff networks, increase maxiter or relax tol.\nAlways monitor constraint residuals if using larger timesteps.\nThermostat steps that randomize velocities should be followed by apply_rattle!.","category":"page"},{"location":"guide/constraints/#Common-Pitfalls","page":"Constrained Dynamics","title":"Common Pitfalls","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Constraints assume well-defined molecular topology. If your system uses PBC,\nensure constrained atoms belong to the same molecule and do not cross cell boundaries unexpectedly.\nA too-tight tolerance can lead to slow or failed convergence.\nDoF reduction is essential: forgetting to pass constraints or remove_com to degrees_of_freedom will bias temperature estimates.","category":"page"},{"location":"guide/constraints/#Further-Reading","page":"Constrained Dynamics","title":"Further Reading","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Ryckaert, Ciccotti & Berendsen (1977), Numerical integration of the Cartesian equations of motion of a system with constraints: molecular dynamics of n-alkanes, J. Comp. Phys. 23(3).\nAndersen (1983), RATTLE: A \"velocity\" version of the SHAKE algorithm for molecular dynamics calculations, J. Comp. Phys. 52(1).","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"These classical references describe the original SHAKE and RATTLE algorithms implemented here.","category":"page"},{"location":"guide/constraints/#Note-on-Particle-Representation","page":"Constrained Dynamics","title":"Note on Particle Representation","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"All positions, velocities, and forces are now represented as Vector{SVector{D, T}} for performance and type stability. Update your code and constraint definitions accordingly.","category":"page"},{"location":"guide/constraints/#See-Also","page":"Constrained Dynamics","title":"See Also","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"ParticleSystem: container for positions, velocities, and masses.\nvelocity_verlet!: unconstrained Velocity-Verlet integrator.\ndegrees_of_freedom: count effective translational degrees of freedom.\nremove_com_motion!: eliminate center-of-mass drift.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"For thermostatting with constraints, project velocities with apply_rattle! after randomization steps to remain on the constraint manifold.","category":"page"},{"location":"guide/constraints/#Next-Steps","page":"Constrained Dynamics","title":"Next Steps","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"You can now combine constrained dynamics with neighbor lists, Lennard-Jones forces, and thermostats. See the Forces & Potentials guide for force field setup.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Summary: SHAKE/RATTLE constraints in Verlet.jl let you simulate rigid bonds, stabilize molecules, and safely increase integration timesteps. Use them with care, monitor convergence, and adjust tolerances as needed.","category":"page"}]
}
