var documenterSearchIndex = {"docs":
[{"location":"specs/Spec_Neighbors/#Spec:-Module-Verlet.Neighbors","page":"Neighbors","title":"Spec: Module Verlet.Neighbors","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"Purpose: Efficient neighbor list construction and orchestration for force evaluation.","category":"page"},{"location":"specs/Spec_Neighbors/#Types","page":"Neighbors","title":"Types","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"struct NeighborPair{F<:AbstractPotentialPair, IntT<:Integer}\ni::IntT, j::IntT, pair::F (per-pair parameters).\nconst PotentialNeighborList{F} = StructArray{NeighborPair{F,T_Int}} where {F<:AbstractPotentialPair}\nPer-potential neighbor container (StructArray-backed for SoA layout).\nstruct MasterNeighborEntry{T_Float,T_Int<:Integer}\ni::T_Int, j::T_Int, r2::T_Float (squared distance with minimum-image).\nmutable struct MasterNeighborList{T<:Number} <: AbstractNeighborList\nskin::T, entries::Vector{MasterNeighborEntry}.\nConstructor: MasterNeighborList(skin; sizehint=1000).","category":"page"},{"location":"specs/Spec_Neighbors/#Building-neighbors","page":"Neighbors","title":"Building neighbors","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"build_master_neighborlist!(master, positions, box; r_verlet, method=:cells)\nPurpose: Fill master.entries with unique pairs (i<j) within cutoff r_verlet (plus algorithmic skin as needed).\nMethods:\n:cells (default): cell-list algorithm, expected O(N).\n:bruteforce: all i<j pairs, O(N^2); useful for small N or debugging.\n:all_pairs: include all pairs regardless of cutoff (testing/no-cutoff potentials).\nSemantics: r2 is computed with minimum-image in the provided box.\nbuild_cellgrid(...), rebin!(...)\nUtilities for the cell-list implementation (internal surface area; caller rarely uses directly).","category":"page"},{"location":"specs/Spec_Neighbors/#ForceField-integration","page":"Neighbors","title":"ForceField integration","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"build_neighbors_from_master!(pot::AbstractPairPotential, sys::System, master::MasterNeighborList)\nPopulates pot.neighborlist using master.entries and per-type pair parameters.\nIncludes a pair (i,j) if not excluded and entry.r2 < (p.rc + pot.skin)^2.\nbuild_all_neighbors!(master, ff::ForceField, sys::System; method=:cells)\nComputes a master list with r_verlet = maximum(max(p.rc) + pot.skin for pot in ff.layers) (over all layer parameter tables), then builds per-layer lists.","category":"page"},{"location":"specs/Spec_Neighbors/#Exclusions","page":"Neighbors","title":"Exclusions","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"is_excluded(pot::AbstractPairPotential, i, j)\nBasic tuple membership check on pot.exclusions (callers can precompute or specialize for performance).","category":"page"},{"location":"specs/Spec_Neighbors/#Invariants","page":"Neighbors","title":"Invariants","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"master.entries contains unique (i<j) pairs; no self-pairs; r2 ≥ 0.\nPer-potential neighbor lists are empty!+push!-rebuilt; capacity may be retained.","category":"page"},{"location":"specs/Spec_Neighbors/#Performance","page":"Neighbors","title":"Performance","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"Cell-list path is expected O(N) with good binning; bruteforce is O(N^2).\nStructArray neighbors enable tight loops in potentials (good cache behavior).","category":"page"},{"location":"specs/Spec_Neighbors/#Example","page":"Neighbors","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"using Verlet, StaticArrays\nbox = CubicBox(10.0)\nR = [@SVector randn(3) for _ in 1:128]; wrap_positions!(R, box)\nsys = System(R, fill(@SVector zeros(3), 128), fill(@SVector zeros(3), 128), ones(128), box, ones(Int,128), Dict(1=>:A))\n\nlj = begin\n  params = PairTable(fill(LJPair(1.0, 1.0, 2.5), (1,1)))\n  Verlet.Potentials.LennardJones(params, Tuple{Int,Int}[], 0.5)\nend\nff = ForceField((lj,))\nmaster = MasterNeighborList(0.5)\nbuild_all_neighbors!(master, ff, sys; method=:cells)","category":"page"},{"location":"specs/Spec_Neighbors/#Cell-Grid-Details","page":"Neighbors","title":"Cell Grid Details","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"CellGrid{IT,T} fields:\nL::T: cubic box length; assumed consistent with positions’ units.\ncell_size::T: effective uniform cell width actually used for binning.\ndims::NTuple{3,IT}: (nx,ny,nz); each ≥ 1.\nheads::Vector{IT}: length nx*ny*nz; head index per cell (0 sentinel = empty).\nnext::Vector{IT}: length N; intrusive linked-list “next” pointer per particle (0 = end).\nBuild and rebin:\nbuild_cellgrid(R, box; cell_size) constructs a grid sized so that the effective width cs_eff = L / floor(L/cell_size) ≥ cell_size and immediately rebin!s the positions.\nrebin!(grid, R, box) resets heads and next and push-fronts each particle index i into its cell list using periodic mapping.\nIndexing and periodicity:\nPositions are mapped to [0, L) via x0 = x + 0.5L; x0 -= floor(x0 / L) * L, then to cell indices 1..n via floor(x0/cell_size)+1 clamped to [1,n].\nCell linear index: ((cz-1)*ny + (cy-1))*nx + cx.\n27-neighbor stencil computed by _neighbors_of_cell using mod1 periodic wrap per axis.","category":"page"},{"location":"specs/Spec_Neighbors/#Master-List-Algorithm","page":"Neighbors","title":"Master List Algorithm","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"Methods in build_master_neighborlist!:\n:cells (default):\nEnsure a compatible grid: if no grid provided, or grid.cell_size < rlist or grid.L != box.L, build a new grid with cell_size=rlist; otherwise rebin!.\nFor each cell: for each particle i in the cell’s list:\nSame-cell pairs: traverse j = next[i] chain, test r2 ≤ rlist2 using minimum-image, and push!(i<j).\nNeighbor cells: iterate the 27 neighbors; to avoid duplicates, only process neighbor cell cc_idx if c_idx < cc_idx, then traverse heads[cc_idx] list and test pairs.\nAfter filling, sort! by (i,j) and unique! the entries.\n:bruteforce: nested loops for i<j, compute r2 with minimum-image and push if r2 ≤ rlist2.\n:all_pairs: nested loops for i<j, always push with computed r2 (no cutoff).\nRadii:\nrlist2 = (r_verlet + master_nl.skin)^2 for :cells and :bruteforce. :all_pairs ignores rlist2.","category":"page"},{"location":"specs/Spec_Neighbors/#Sorting-and-Uniqueness","page":"Neighbors","title":"Sorting and Uniqueness","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":":cells path sorts and de-duplicates entries defensively, even though the neighbor sweep avoids double counting by c_idx < cc_idx and i<j ordering.\n:bruteforce and :all_pairs generate unique (i<j) pairs by construction and do not sort/unique.","category":"page"},{"location":"specs/Spec_Neighbors/#Grid-Reuse-Policy","page":"Neighbors","title":"Grid Reuse Policy","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"Pass an existing grid to build_master_neighborlist! to avoid reallocations.\nThe grid is rebuilt if the requested list radius grows (grid.cell_size < rlist) or the box length changes; otherwise positions are re-binned in-place.","category":"page"},{"location":"specs/Spec_Neighbors/#Assumptions-and-Invariants","page":"Neighbors","title":"Assumptions and Invariants","text":"","category":"section"},{"location":"specs/Spec_Neighbors/","page":"Neighbors","title":"Neighbors","text":"Positions are 3D SVector{3,T}; the builder asserts d=3.\nMasterNeighborEntry stores (i<j, r2≥0) with r2 computed under minimum-image in the provided CubicBox.\nmaster.entries is cleared (resize!(…,0)) before population.","category":"page"},{"location":"numerics/#Numerical-Notes","page":"Numerical Notes","title":"Numerical Notes","text":"","category":"section"},{"location":"numerics/#Constraint-Tolerances-and-Thermostat-Parameters","page":"Numerical Notes","title":"Constraint Tolerances and Thermostat Parameters","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"When using langevin_baoab_constrained!, the SHAKE and RATTLE solvers enforce distance constraints up to the tolerance specified in DistanceConstraints.","category":"page"},{"location":"numerics/#Interplay-with-γ-and-T","page":"Numerical Notes","title":"Interplay with γ and T","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Larger friction γ and higher temperature T produce stronger stochastic kicks in the OU step.\nThis may increase the number of iterations needed for constraint convergence.\nIf the solver fails to converge within maxiter, consider relaxing tol slightly.","category":"page"},{"location":"numerics/#Mass-Variance","page":"Numerical Notes","title":"Mass Variance","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Constraints involving very light particles (e.g. hydrogens) can converge more slowly if highly coupled with heavier atoms. This is expected and usually acceptable for simple bond constraints.","category":"page"},{"location":"numerics/#Degrees-of-Freedom-and-Temperature","page":"Numerical Notes","title":"Degrees of Freedom and Temperature","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"The function instantaneous_temperature uses the full degrees of freedom by default. For constrained systems, users who want diagnostics consistent with statistical mechanics should instead call:","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"degrees_of_freedom(sys; constraints=cons, remove_com=false)","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"and use this value in temperature calculations.","category":"page"},{"location":"numerics/#Reproducibility","page":"Numerical Notes","title":"Reproducibility","text":"","category":"section"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"The stochastic step uses the provided RNG. Set a fixed seed (e.g. rng = MersenneTwister(1234)) in tests or benchmarks for reproducibility.","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"","category":"page"},{"location":"numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"See also: constraint_residuals for monitoring how well constraints are satisfied.","category":"page"},{"location":"specs/Spec_Module_Index/#Spec-Index","page":"Overview","title":"Spec Index","text":"","category":"section"},{"location":"specs/Spec_Module_Index/","page":"Overview","title":"Overview","text":"Top-level: Verlet\nCore: Verlet.Core\nNeighbors: Verlet.Neighbors\nPotentials: Verlet.Potentials\nConstraints: Verlet.Constraints\nThermostats: Verlet.Thermostats\nElectrostatics: Verlet.Electrostatics","category":"page"},{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [\n    Verlet.Core,\n    Verlet.Neighbors,\n    Verlet.Potentials,\n    Verlet.Constraints,\n    Verlet.Thermostats\n]\nOrder = [:function, :type]","category":"page"},{"location":"api/#Verlet.Core.AbstractBox","page":"API","title":"Verlet.Core.AbstractBox","text":"abstract type AbstractBox{T<:AbstractFloat} end\n\nAbstract type for simulation boxes.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Core.CubicBox","page":"API","title":"Verlet.Core.CubicBox","text":"struct CubicBox{T<:AbstractFloat} <: AbstractBox{T}\n\nSimple cubic periodic box with side length L.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Core.System","page":"API","title":"Verlet.Core.System","text":"System(T<:AbstractFloat, IT<:Integer, Dims)\n\nA flexible and type-stable container for particle-based simulations.\n\nType Parameters\n\nT<:AbstractFloat: Floating-point type for particle properties (e.g., Float32, Float64).\nIT<:Integer: Integer type for particle indices and types (e.g., Int32, Int64).\nDims: The number of spatial dimensions.\n\nFields\n\npositions::Vector{SVector{Dims, T}}: Particle positions.\nvelocities::Vector{SVector{Dims, T}}: Particle velocities.\nforces::Vector{SVector{Dims, T}}: Forces acting on particles.\nmasses::Vector{T}: Particle masses.\nbox::AbstractBox{T}: Simulation box defining the periodic boundary conditions.\ntypes::Vector{IT}: Particle type identifiers (integers).\ntype_names::Dict{IT, Symbol}: Mapping from type identifiers to descriptive names (e.g., 1 => :H).\nnatoms::IT: Total number of atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Core.kinetic_energy-Union{Tuple{System{T, IT, Dims}}, Tuple{Dims}, Tuple{IT}, Tuple{T}} where {T, IT, Dims}","page":"API","title":"Verlet.Core.kinetic_energy","text":"kinetic_energy(sys::System) -> T\n\nTotal kinetic energy: ∑ ½ mᵢ ‖vᵢ‖².\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.minimum_image-Tuple{AbstractVector, CubicBox}","page":"API","title":"Verlet.Core.minimum_image","text":"minimum_image(Δ, box::CubicBox)\nminimum_image(Δ, L)\n\nApply the minimum-image convention to the displacement vector Δ for the periodic box (wraps components to (-L/2, L/2]) and return the new vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.natoms-Tuple{System}","page":"API","title":"Verlet.Core.natoms","text":"natoms(sys::System) -> Integer\n\nGet the number of atoms in the system.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.natomtypes-Tuple{System}","page":"API","title":"Verlet.Core.natomtypes","text":"natomtypes(sys::System) -> Int\n\nGet the number of unique atom types in the system.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.potential_energy-Union{Tuple{Dims}, Tuple{IT}, Tuple{T}, Tuple{System{T, IT, Dims}, Function}} where {T, IT, Dims}","page":"API","title":"Verlet.Core.potential_energy","text":"potential_energy(system::System{T,IT,Dims}, forces::Function) -> T\n\nTry to obtain total potential energy using forces(...; return_potential=true) convention.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.velocity_verlet!-Union{Tuple{Dims}, Tuple{IT}, Tuple{T}, Tuple{System{T, IT, Dims}, Function, T}} where {T, IT, Dims}","page":"API","title":"Verlet.Core.velocity_verlet!","text":"velocity_verlet!(system::System{T,IT,Dims}, forces::Function, dt::T) where {T,IT,Dims}\n\nAdvance system by one timestep dt using the velocity Verlet integrator.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Core.wrap_positions!-Union{Tuple{T}, Tuple{Dims}, Tuple{Array{StaticArraysCore.SVector{Dims, T}, 1}, CubicBox{T}}} where {Dims, T<:AbstractFloat}","page":"API","title":"Verlet.Core.wrap_positions!","text":"wrap_positions!(R, box::CubicBox)\n\nWrap particle positions R into the primary periodic image of box in-place. This is useful before building neighbor lists or measuring displacements.\n\nThe resulting positions will be in the range (-L/2, L/2].\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.CellGrid","page":"API","title":"Verlet.Neighbors.CellGrid","text":"CellGrid{IT<:Integer, T<:Real}\n\nLinked-list cell grid for cubic periodic boxes. The domain is split into a uniform dims = (nx,ny,nz) grid of cubic cells with an intrusive linked list (heads, next) storing particle indices in each cell. This enables O(N) rebinning at fixed density and powers the O(N) neighbor build.\n\nFields\n\nL::T: cubic box length.\ncell_size::T: effective uniform cell width actually used for binning.\ndims::NTuple{3,IT}: number of cells along each axis (each ≥ 1).\nheads::Vector{IT}: length nx*ny*nz; head index per cell (0 sentinel = empty).\nnext::Vector{IT}: length N; linked list “next” pointer per particle (0 = end).\n\ntip: How `cell_size` is chosen\nbuild_cellgrid computes nx = floor(Int, L/cell_size) and then uses the effective width L/nx for indexing so that a 27-cell sweep is sufficient for a search radius ≤ cell_size.\n\nwarning: Units\nR and L must be expressed in the same length units.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Neighbors.build_cellgrid-Tuple{AbstractVector, Any}","page":"API","title":"Verlet.Neighbors.build_cellgrid","text":"build_cellgrid(R, box; cell_size)\n\nCreate a new CellGrid sized for cell_size and bin positions R (N×3). Returns a populated grid with linked lists set for particle indices 1..N.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.build_master_neighborlist!-Tuple{MasterNeighborList, AbstractVector, CubicBox}","page":"API","title":"Verlet.Neighbors.build_master_neighborlist!","text":"build_master_neighborlist!(master_nl, R, box; r_verlet, skin, method=:cells, grid=nothing)\n\nUpdate a master neighbor list in-place.\n\nThe method keyword argument can be one of:\n\n:cells: Use an O(N) cell-linked grid build (default).\n:bruteforce: Use an O(N^2) brute-force build.\n:all_pairs: Include all pairs, ignoring the cutoff.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Neighbors.rebin!-Union{Tuple{T}, Tuple{IT}, Tuple{Verlet.Neighbors.CellGrid{IT, T}, AbstractVector, Any}} where {IT<:Integer, T<:Real}","page":"API","title":"Verlet.Neighbors.rebin!","text":"rebin!(grid, R, box) -> grid\n\nReset the grid's heads and next and bin the positions R into cells according to the current cell_size and periodic cubic box box.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Potentials.CoulPair","page":"API","title":"Verlet.Potentials.CoulPair","text":"CoulPair{T<:Number}\n\nParameters for a Coulomb interaction between two particle types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Potentials.LJPair","page":"API","title":"Verlet.Potentials.LJPair","text":"LJPair{T<:Number}\n\nParameters for a Lennard-Jones interaction between two particle types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Potentials.PairTable","page":"API","title":"Verlet.Potentials.PairTable","text":"PairTable{F<:AbstractPotentialPair}\n\nA table to store parameters for each pair of particle types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Constraints.DistanceConstraints","page":"API","title":"Verlet.Constraints.DistanceConstraints","text":"struct DistanceConstraints{T_Int,T_Float}\n\nImmutable set of pairwise distance constraints for SHAKE/RATTLE.\n\n\n\n\n\n","category":"type"},{"location":"api/#Verlet.Constraints.apply_rattle!-Tuple{System, DistanceConstraints}","page":"API","title":"Verlet.Constraints.apply_rattle!","text":"apply_rattle!(sys, cons)\n\nCorrect velocities to satisfy velocity constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.apply_shake!-Tuple{System, DistanceConstraints, Any}","page":"API","title":"Verlet.Constraints.apply_shake!","text":"apply_shake!(sys, cons, dt)\n\nIteratively correct positions to satisfy constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.constraint_residuals-Tuple{System, DistanceConstraints}","page":"API","title":"Verlet.Constraints.constraint_residuals","text":"constraint_residuals(sys::System, cons::DistanceConstraints) -> (; maxC, rmsC, maxCd, rmsCd)\n\nCompute the constraint residuals for a system subject to pairwise distance constraints.\n\nFor each constraint l with atoms (i, j) and target distance r0_l:\n\nPosition residual: C_l = ||r_i - r_j||^2 - r0_l^2\nVelocity residual: Ċ_l = 2 (r_i - r_j) ⋅ (v_i - v_j)\n\nReturns a named tuple with maxC, rmsC, maxCd, rmsCd.\n\nExample\n\nsys = System(\n    [SVector(0.0, 0, 0), SVector(1.0, 0, 0)],\n    [SVector(0.0, 0, 0), SVector(0.0, 0, 0)],\n    [SVector(0.0, 0, 0), SVector(0.0, 0, 0)],\n    [1.0, 1.0],\n    CubicBox(10.0),\n    [1, 1],\n    Dict(1 => :A)\n)\ncons = DistanceConstraints([(1,2)], [1.0])\nconstraint_residuals(sys, cons)\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.remove_com_motion!-Tuple{System}","page":"API","title":"Verlet.Constraints.remove_com_motion!","text":"remove_com_motion!(sys; which=:velocity)\n\nRemove center-of-mass motion from velocities/positions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Constraints.velocity_verlet_shake_rattle!-Tuple{System, Any, Any, DistanceConstraints}","page":"API","title":"Verlet.Constraints.velocity_verlet_shake_rattle!","text":"velocity_verlet_shake_rattle!(sys, forces, dt, cons)\n\nConstrained velocity Verlet step with SHAKE/RATTLE.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.degrees_of_freedom-Tuple{System}","page":"API","title":"Verlet.Thermostats.degrees_of_freedom","text":"degrees_of_freedom(sys; constraints=nothing, remove_com=false) -> Int\n\nEffective translational DoF, reduced by number of constraints and optionally COM removal. This is the canonical method. A no-keyword fallback is provided for backward compatibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.instantaneous_temperature-Union{Tuple{System{T, IT, Dims}}, Tuple{Dims}, Tuple{IT}, Tuple{T}} where {T, IT, Dims}","page":"API","title":"Verlet.Thermostats.instantaneous_temperature","text":"instantaneous_temperature(sys; kB=1.0) -> Float64\n\nCompute instantaneous temperature via equipartition: T = 2 * KE / (kB * dof).\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.langevin_baoab!-Union{Tuple{Dims}, Tuple{IT}, Tuple{T}, Tuple{System{T, IT, Dims}, Any, Any}} where {T, IT, Dims}","page":"API","title":"Verlet.Thermostats.langevin_baoab!","text":"langevin_baoab!(sys, forces, dt; γ, T, kB=1.0, rng=Random.default_rng())\n\nAdvance one step with the Langevin BAOAB integrator: B(half) → A(half) → O(OU) → A(half) → B(half). With γ=0, this reduces to velocity-Verlet (deterministic).\n\nArguments\n\nsys     : particle system\nforces : callable F = forces(positions)\ndt     : time step\n\nKeywords\n\nγ  : friction (1/time)\nT  : target temperature\nkB : Boltzmann constant (default 1.0)\nrng: AbstractRNG for reproducibility\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.langevin_baoab_constrained!-Union{Tuple{Dims}, Tuple{IT}, Tuple{T}, Tuple{System{T, IT, Dims}, Any, Any, DistanceConstraints}} where {T, IT, Dims}","page":"API","title":"Verlet.Thermostats.langevin_baoab_constrained!","text":"langevin_baoab_constrained!(sys::System, forces, dt, cons::DistanceConstraints;\n                            γ, T, kB=1.0, rng=Random.default_rng())\n\nAdvance one constrained NVT BAOAB step with SHAKE/RATTLE projections.\n\nSplitting and projections:\n\nB (half kick)         → apply_rattle! (velocities)\nA (half drift)        → apply_shake! (positions)\nO (OU stochastic)     → apply_rattle! (velocities)\nA (half drift)        → apply_shake! (positions)\nRecompute forces\nB (half kick)         → apply_rattle! (velocities)\n\nNotes:\n\nUses exp(-γ*dt) for the OU decay. Noise variance is (1 - c^2) * kB*T / m_i per component.\nWith constraints, prefer this method over the unconstrained langevin_baoab!.\n\n\n\n\n\n","category":"method"},{"location":"api/#Verlet.Thermostats.velocity_rescale!-Tuple{System, Real}","page":"API","title":"Verlet.Thermostats.velocity_rescale!","text":"velocity_rescale!(sys, T; kB=1.0)\n\nDeterministically rescale velocities to match target temperature T.\n\n\n\n\n\n","category":"method"},{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Molecular systems often contain rigid bonds or fixed distances between atoms. These are represented using the DistanceConstraints type and enforced using SHAKE (positions) and RATTLE (velocities).","category":"page"},{"location":"constraints/#Residual-Monitoring","page":"Constraints","title":"Residual Monitoring","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"The helper function constraint_residuals reports how well constraints are satisfied at a given state:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"maxC, rmsC — maximum and RMS positional residuals\nmaxCd, rmsCd — maximum and RMS velocity residuals","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"using Verlet, StaticArrays\npositions = [SVector{3}(0.0, 0.0, 0.0), SVector{3}(1.0, 0.0, 0.0)]\nvelocities = [SVector{3}(0.0, 0.0, 0.0) for _ in 1:2]\nforces = [SVector{3}(0.0, 0.0, 0.0) for _ in 1:2]\nmasses = ones(2)\nbox = CubicBox(10.0)\ntypes = [1, 1]\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names)\ncons = DistanceConstraints([(1,2)], [1.0])\nconstraint_residuals(sys, cons)","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"These values are useful for debugging and regression testing.","category":"page"},{"location":"constraints/#Usage-with-cBAOAB","page":"Constraints","title":"Usage with cBAOAB","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"When running constrained Langevin dynamics with langevin_baoab_constrained!, residuals should remain close to machine precision (typically 1e-8 or smaller) if the solver tolerance is sufficiently strict.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"See also:","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"apply_shake!\napply_rattle!\nlangevin_baoab_constrained!","category":"page"},{"location":"specs/Spec_Potentials/#Spec:-Module-Verlet.Potentials","page":"Potentials","title":"Spec: Module Verlet.Potentials","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"Purpose: Define concrete interatomic potentials and per-pair parameter tables; integrate with neighbor lists for efficient force evaluation.","category":"page"},{"location":"specs/Spec_Potentials/#Pair-parameter-structs","page":"Potentials","title":"Pair parameter structs","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"struct LJPair{T<:Number} <: AbstractPotentialPair\nε::T, σ::T, rc::T (cutoff).\nstruct CoulPair{T<:Number} <: AbstractPotentialPair\nq1q2::T (charge product), rc::T.\nstruct PairTable{F<:AbstractPotentialPair}\ntable::Matrix{F} mapping (type_i, type_j) to parameter objects.","category":"page"},{"location":"specs/Spec_Potentials/#Concrete-pair-potentials","page":"Potentials","title":"Concrete pair potentials","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"mutable struct LennardJones{IntT<:Integer, T<:AbstractPotentialPair, T_Float} <: AbstractPairPotential\nFields: params::PairTable{T}, exclusions::Vector{Tuple{IntT,IntT}}, neighbors::PotentialNeighborList{T}, skin::T_Float.\nConstructor: LennardJones(params::PairTable{T}, exclusions, skin) initializes empty neighbor list.\ncompute_forces!(pot::LennardJones, sys::System)\nFor each neighbor (i,j,p), computes minimum-image displacement Δ, r2 = Δ⋅Δ.\nIf r2 < p.rc^2, apply LJ 12-6 force: f = 24ε(2(σ^12/r^13) - (σ^6/r^7)) Δ/‖Δ‖ (implemented in r2 form for efficiency) and accumulate on sys.forces[i]/[j].\nmutable struct Coulomb{IntT<:Integer, T<:AbstractPotentialPair, T_Float} <: AbstractPairPotential\nFields analogous to LennardJones but with CoulPair parameters.\ncompute_forces!(pot::Coulomb, sys::System)\nFor each neighbor within cutoff, f = (q1q2 / r^3) Δ (with minimum-image) and accumulate.","category":"page"},{"location":"specs/Spec_Potentials/#Bonded-potentials-and-instances","page":"Potentials","title":"Bonded potentials and instances","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"Potential parameters\nstruct HarmonicBond{T} <: AbstractBondPotential with k, r0.\nstruct HarmonicAngle{T} <: AbstractAnglePotential with k, θ0.\nstruct PeriodicDihedral{T} <: AbstractDihedralPotential with k, n::Int, ϕ0.\nInteraction instances (bind particles to parameters)\nstruct Bond{T<:AbstractBondPotential} with particles (i,j) and potential::T.\nstruct Angle{T<:AbstractAnglePotential} with (i,j,k) and potential::T.\nstruct Dihedral{T<:AbstractDihedralPotential} with (i,j,k,l) and potential::T.\nForce implementations\ncompute_forces!(bond::Bond, system) harmonic stretch along bond axis.\ncompute_forces!(angle::Angle, system) harmonic deviation of angle at j.\ncompute_forces!(dihedral::Dihedral, system) periodic torsion per OpenMM formulas.","category":"page"},{"location":"specs/Spec_Potentials/#Integration-with-Core.ForceField","page":"Potentials","title":"Integration with Core.ForceField","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"Pair potentials are included in ForceField((lj, coul, ...)) and must have neighbors prebuilt via Neighbors.build_all_neighbors!.\nBonded interactions should be placed in system.specific_potentials for automatic inclusion by compute_all_forces!.","category":"page"},{"location":"specs/Spec_Potentials/#Exclusions","page":"Potentials","title":"Exclusions","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"Each pair potential carries exclusions::Vector{Tuple{Int,Int}} checked by Neighbors.is_excluded during neighbor construction.","category":"page"},{"location":"specs/Spec_Potentials/#Invariants-and-Performance","page":"Potentials","title":"Invariants & Performance","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"neighbors lists are cleared and rebuilt; structure capacity may be retained to avoid allocations.\nForce kernels run allocation-free and scale with neighbor count.","category":"page"},{"location":"specs/Spec_Potentials/#Examples","page":"Potentials","title":"Examples","text":"","category":"section"},{"location":"specs/Spec_Potentials/","page":"Potentials","title":"Potentials","text":"using Verlet, StaticArrays\nbox = CubicBox(8.0)\nR = [@SVector randn(3) for _ in 1:64]; wrap_positions!(R, box)\nsys = System(R, fill(@SVector zeros(3),64), fill(@SVector zeros(3),64), ones(64), box, ones(Int,64), Dict(1=>:A))\n\nparams = PairTable(fill(LJPair(1.0, 1.0, 2.5), (1,1)))\nlj = LennardJones(params, Tuple{Int,Int}[], 0.5)\nff = Verlet.Neighbors.ForceField((lj,))\nmaster = Verlet.Neighbors.MasterNeighborList(0.5)\nVerlet.Neighbors.build_all_neighbors!(master, ff, sys)\nVerlet.Neighbors.compute_all_forces!(sys, ff)","category":"page"},{"location":"specs/Spec_Constraints/#Spec:-Module-Verlet.Constraints","page":"Constraints","title":"Spec: Module Verlet.Constraints","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"Purpose: Represent and enforce pair distance constraints via SHAKE/RATTLE, provide diagnostics and utilities.","category":"page"},{"location":"specs/Spec_Constraints/#Types","page":"Constraints","title":"Types","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"struct DistanceConstraints{T_Int,T_Float}\ni::Vector{T_Int}, j::Vector{T_Int}: constrained pairs (1-based indices).\nr0::Vector{T_Float}: target distances.\ntol::T_Float, maxiter::T_Int: solver tolerance and max iterations.\nuse_minimum_image::Bool: whether to apply minimum-image using sys.box.\nConvenience constructor: DistanceConstraints(pairs::Vector{<:Tuple}, lengths::Vector{<:Real}; tol=1e-8, maxiter=50, use_minimum_image=true).","category":"page"},{"location":"specs/Spec_Constraints/#Solvers","page":"Constraints","title":"Solvers","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"apply_shake!(sys::System, cons::DistanceConstraints, dt)\nIteratively correct positions to satisfy ‖r_i − r_j‖^2 = r0^2 up to tol.\nUses Lagrange multiplier update Δλ = −C/(2σ) with σ = (1/m_i + 1/m_j)‖Δ‖^2.\nErrors if not converged within maxiter or if σ ≈ 0 (ill-conditioned).\napply_rattle!(sys::System, cons::DistanceConstraints)\nCorrect velocities to satisfy Ċ = 2Δ⋅(v_i − v_j) = 0 up to tol.\nSimilar iteration with μ = −(Δ⋅v_rel) / τ, τ = (1/m_i + 1/m_j)‖Δ‖^2.","category":"page"},{"location":"specs/Spec_Constraints/#Time-integration","page":"Constraints","title":"Time integration","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"velocity_verlet_shake_rattle!(sys, forces, dt, cons)\nConstrained velocity-Verlet: half kick → drift → SHAKE → new forces → half kick → RATTLE.","category":"page"},{"location":"specs/Spec_Constraints/#Utilities","page":"Constraints","title":"Utilities","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"remove_com_motion!(sys; which=:velocity|:position|:both)\nRemove center-of-mass motion from velocities and/or positions.\nconstraint_residuals(sys::System, cons::DistanceConstraints) → (; maxC, rmsC, maxCd, rmsCd)\nReports maximum and RMS residuals for positions and velocities.","category":"page"},{"location":"specs/Spec_Constraints/#Performance","page":"Constraints","title":"Performance","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"Each SHAKE/RATTLE sweep is O(#constraints); iteration count depends on tolerance and system state.\nuse_minimum_image reduces discontinuities under PBCs for bonds crossing boundaries.","category":"page"},{"location":"specs/Spec_Constraints/#Failure-modes","page":"Constraints","title":"Failure modes","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"Ill-conditioned constraints (zero-length Δ or huge mass mismatch) may trigger errors.\nNon-convergence raises an error with the configured maxiter.","category":"page"},{"location":"specs/Spec_Constraints/#Example","page":"Constraints","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Constraints/","page":"Constraints","title":"Constraints","text":"using Verlet, StaticArrays\nR = [SVector(0.0,0,0), SVector(1.0,0,0)]\nV = [SVector(0.0,0,0), SVector(0.0,0,0)]\nF = [SVector(0.0,0,0), SVector(0.0,0,0)]\nsys = System(R, V, F, [1.0,1.0], CubicBox(10.0), [1,1], Dict(1=>:A))\ncons = DistanceConstraints([(1,2)], [1.0])\nvelocity_verlet_shake_rattle!(sys, R->F, 0.001, cons)\nres = constraint_residuals(sys, cons)","category":"page"},{"location":"specs/Spec_Thermostats/#Spec:-Module-Verlet.Thermostats","page":"Thermostats","title":"Spec: Module Verlet.Thermostats","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"Purpose: Thermostatting utilities and Langevin BAOAB integrators (un/constrained).","category":"page"},{"location":"specs/Spec_Thermostats/#Degrees-of-freedom-and-temperature","page":"Thermostats","title":"Degrees of freedom and temperature","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"degrees_of_freedom(sys; constraints=nothing, remove_com=false) -> Int\nN*D reduced by number of constraints and optionally by D if COM removed.\ninstantaneous_temperature(sys; kB=1.0)\nT = 2*KE / (kB * dof) using degrees_of_freedom(sys).\nvelocity_rescale!(sys, T; kB=1.0)\nDeterministically rescales velocities by λ = sqrt(T/ max(Tinst, eps())).","category":"page"},{"location":"specs/Spec_Thermostats/#Langevin-BAOAB-(unconstrained)","page":"Thermostats","title":"Langevin BAOAB (unconstrained)","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"langevin_baoab!(sys, forces, dt; γ, temp, kB=1.0, rng=Random.default_rng())\nSplitting: B(½) → A(½) → O → A(½) → B(½).\nOU step uses c = exp(-γ*dt) (with a stable series fallback internally) and noise variance (1-c^2) * kB*temp / m_i per component.\nWith γ=0 reduces to deterministic velocity-Verlet.","category":"page"},{"location":"specs/Spec_Thermostats/#Constrained-Langevin-BAOAB","page":"Thermostats","title":"Constrained Langevin BAOAB","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"langevin_baoab_constrained!(sys, forces, dt, cons::DistanceConstraints; γ, temp, kB=1.0, rng=Random.default_rng())\nSplitting with projections:\nB(½) → apply_rattle!\nA(½) → apply_shake!\nO → apply_rattle!\nA(½) → apply_shake!\nRecompute forces\nB(½) → apply_rattle!\nRecommended path when rigid bonds/constraints are present.","category":"page"},{"location":"specs/Spec_Thermostats/#Invariants-and-Notes","page":"Thermostats","title":"Invariants & Notes","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"All updates are in-place on sys.positions/sys.velocities.\nforces(R) must return a vector of force vectors aligned with R and is called twice per BAOAB step (unconstrained) or once before/after projections (constrained).\nFor reproducibility, pass an explicit RNG.","category":"page"},{"location":"specs/Spec_Thermostats/#Example","page":"Thermostats","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Thermostats/","page":"Thermostats","title":"Thermostats","text":"using Verlet, StaticArrays, Random\nbox = CubicBox(5.0)\nR = [@SVector randn(3) for _ in 1:8]; wrap_positions!(R, box)\nsys = System(R, fill(@SVector zeros(3),8), fill(@SVector zeros(3),8), ones(8), box, ones(Int,8), Dict(1=>:A))\nforces = R -> [ -r for r in R ]\nlangevin_baoab!(sys, forces, 0.001; γ=1.0, temp=1.0, rng=MersenneTwister(1))","category":"page"},{"location":"guide/constraints/#Constrained-Dynamics-(SHAKE/RATTLE)","page":"Constrained Dynamics","title":"Constrained Dynamics (SHAKE/RATTLE)","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"@id constraints-guide","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Molecular simulations often require certain bond lengths (e.g. X–H bonds in water) to remain fixed. This enables larger stable timesteps and enforces realistic rigid-body structures.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Verlet.jl provides support for holonomic distance constraints using the classical SHAKE (positions) and RATTLE (velocities) algorithms.","category":"page"},{"location":"guide/constraints/#Defining-Constraints","page":"Constrained Dynamics","title":"Defining Constraints","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Use DistanceConstraints to define a set of pairwise distance constraints:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using Verlet, StaticArrays\n# A diatomic molecule with target bond length 1.0\npairs   = [(1,2)]\nlengths = [1.0]\ncons = DistanceConstraints(pairs, lengths; tol=1e-10, maxiter=100)","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Arguments:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"pairs: vector of (i,j) atom index pairs (1-based)\nlengths: vector of target distances\ntol: maximum squared violation tolerated (|C_l| units length²)\nmaxiter: maximum SHAKE/RATTLE iterations per step\nuse_minimum_image: apply minimum image convention under periodic boundaries","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"tip: Tip\nFor constraints across periodic boundaries, keep molecules whole and use use_minimum_image=true.","category":"page"},{"location":"guide/constraints/#Constrained-Integrator","page":"Constrained Dynamics","title":"Constrained Integrator","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"The velocity_verlet_shake_rattle! driver advances the system with constraints enforced:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using Verlet, StaticArrays, LinearAlgebra\nN, D = 2, 3\npositions = [@SVector zeros(D) for _ in 1:N]\npositions[2] = @SVector [1.2, 0.0, 0.0]   # initial bond slightly off\nvelocities = [@SVector zeros(D) for _ in 1:N]\nforces = [@SVector zeros(D) for _ in 1:N]\nmasses = ones(N)\nbox = CubicBox(10.0)\ntypes = ones(Int, N)\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names)\ncons = DistanceConstraints([(1,2)], [1.0])\nforces_func(R) = [@SVector zeros(D) for _ in R]  # no external forces\nfor step in 1:100\n  velocity_verlet_shake_rattle!(sys, forces_func, 0.01, cons)\nend\nd = sys.positions[1] - sys.positions[2]\n@show norm(d)  # ~1.0","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"This integrator:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Updates velocities (half step) and positions (drift).\nApplies SHAKE projection to enforce bond lengths.\nRecomputes forces.\nCompletes velocity update.\nApplies RATTLE projection to enforce velocity constraints.","category":"page"},{"location":"guide/constraints/#Degrees-of-Freedom","page":"Constrained Dynamics","title":"Degrees of Freedom","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Constraints reduce the effective number of degrees of freedom (DoF). The degrees_of_freedom function accounts for:","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"number of atoms × dimensions\nminus one per constraint\nminus dimensions if COM motion is removed","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using StaticArrays\nN, D = 3, 3\npositions = [@SVector zeros(D) for _ in 1:N]\nvelocities = [@SVector zeros(D) for _ in 1:N]\nforces = [@SVector zeros(D) for _ in 1:N]\nmasses = ones(N)\nbox = CubicBox(10.0)\ntypes = ones(Int, N)\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names)\ncons = DistanceConstraints([(1,2)], [1.0])\ndof = degrees_of_freedom(sys; constraints=cons, remove_com=true)\n@show dof","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Correct DoF is essential for unbiased temperature and pressure estimators.","category":"page"},{"location":"guide/constraints/#Removing-Center-of-Mass-Motion","page":"Constrained Dynamics","title":"Removing Center-of-Mass Motion","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Use remove_com_motion! to zero the mass-weighted center-of-mass velocity or position. This prevents unphysical drift of the entire system.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"using StaticArrays\nN, D = 3, 3\npositions = [@SVector zeros(D) for _ in 1:N]\nvelocities = [@SVector ones(D) for _ in 1:N]\nforces = [@SVector zeros(D) for _ in 1:N]\nmasses = [1.0, 2.0, 3.0]\nbox = CubicBox(10.0)\ntypes = ones(Int, N)\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names)\nremove_com_motion!(sys; which=:velocity)\n# After removal, COM velocity should be ~0\nVcom = sum(sys.masses .* map(v -> v[1], sys.velocities)) / sum(sys.masses)\n@show Vcom","category":"page"},{"location":"guide/constraints/#Performance-Notes","page":"Constrained Dynamics","title":"Performance Notes","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"SHAKE/RATTLE typically converge in a few iterations for tree-like molecules.\nFor rings or stiff networks, increase maxiter or relax tol.\nAlways monitor constraint residuals if using larger timesteps.\nThermostat steps that randomize velocities should be followed by apply_rattle!.","category":"page"},{"location":"guide/constraints/#Common-Pitfalls","page":"Constrained Dynamics","title":"Common Pitfalls","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Constraints assume well-defined molecular topology. If your system uses PBC,\nensure constrained atoms belong to the same molecule and do not cross cell boundaries unexpectedly.\nA too-tight tolerance can lead to slow or failed convergence.\nDoF reduction is essential: forgetting to pass constraints or remove_com to degrees_of_freedom will bias temperature estimates.","category":"page"},{"location":"guide/constraints/#Further-Reading","page":"Constrained Dynamics","title":"Further Reading","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Ryckaert, Ciccotti & Berendsen (1977), Numerical integration of the Cartesian equations of motion of a system with constraints: molecular dynamics of n-alkanes, J. Comp. Phys. 23(3).\nAndersen (1983), RATTLE: A \"velocity\" version of the SHAKE algorithm for molecular dynamics calculations, J. Comp. Phys. 52(1).","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"These classical references describe the original SHAKE and RATTLE algorithms implemented here.","category":"page"},{"location":"guide/constraints/#Note-on-Particle-Representation","page":"Constrained Dynamics","title":"Note on Particle Representation","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"All positions, velocities, and forces are now represented as Vector{SVector{D, T}} for performance and type stability. Update your code and constraint definitions accordingly.","category":"page"},{"location":"guide/constraints/#See-Also","page":"Constrained Dynamics","title":"See Also","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"System: container for positions, velocities, and masses.\nvelocity_verlet!: unconstrained Velocity-Verlet integrator.\ndegrees_of_freedom: count effective translational degrees of freedom.\nremove_com_motion!: eliminate center-of-mass drift.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"For thermostatting with constraints, project velocities with apply_rattle! after randomization steps to remain on the constraint manifold.","category":"page"},{"location":"guide/constraints/#Next-Steps","page":"Constrained Dynamics","title":"Next Steps","text":"","category":"section"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"You can now combine constrained dynamics with neighbor lists, Lennard-Jones forces, and thermostats. See the Forces & Potentials guide for force field setup.","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"","category":"page"},{"location":"guide/constraints/","page":"Constrained Dynamics","title":"Constrained Dynamics","text":"Summary: SHAKE/RATTLE constraints in Verlet.jl let you simulate rigid bonds, stabilize molecules, and safely increase integration timesteps. Use them with care, monitor convergence, and adjust tolerances as needed.","category":"page"},{"location":"specs/Spec_Verlet/#Spec:-Module-Verlet","page":"Top-level (Verlet)","title":"Spec: Module Verlet","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"Purpose: Provide a cohesive top-level API by loading internal submodules and re-exporting core types and functions for users.\nSubmodules: Core, Neighbors, Potentials, Constraints, Thermostats (and Electrostatics WIP).","category":"page"},{"location":"specs/Spec_Verlet/#Re-exports-(user-facing)","page":"Top-level (Verlet)","title":"Re-exports (user-facing)","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"Core: System, natoms, natomtypes, AbstractBox, CubicBox, minimum_image, wrap_positions!, box_length, velocity_verlet!, potential_energy, kinetic_energy, T_Float, T_Int, Dims.\nNeighbor types: NeighborPair, PotentialNeighborList, MasterNeighborEntry, MasterNeighborList.\nPotential types: AbstractPotentialPair, AbstractPairPotential, AbstractBondPotential, AbstractAnglePotential, AbstractDihedralPotential, AbstractImproperPotential.\nConcrete potentials: LennardJones, Coulomb, LJPair, CoulPair, PairTable, Bond, Angle, Dihedral, HarmonicBond, HarmonicAngle, PeriodicDihedral.\nNeighbor building / forcefield: build_master_neighborlist!, build_cellgrid, rebin!, ForceField.\nConstraints: DistanceConstraints, apply_shake!, apply_rattle!, velocity_verlet_shake_rattle!, remove_com_motion!, constraint_residuals.\nThermostats: degrees_of_freedom, instantaneous_temperature, velocity_rescale!, langevin_baoab!, langevin_baoab_constrained!.","category":"page"},{"location":"specs/Spec_Verlet/#Semantics","page":"Top-level (Verlet)","title":"Semantics","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"Importing Verlet is sufficient for most workflows; the above names are available from the top-level module.\nSubmodules can still be accessed directly (e.g., Verlet.Neighbors.ForceField).","category":"page"},{"location":"specs/Spec_Verlet/#Versioning-and-Stability","page":"Top-level (Verlet)","title":"Versioning & Stability","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"Public names re-exported here follow semantic versioning; removals or breaking signature changes increment the major version.\nInternals not re-exported are considered unstable.","category":"page"},{"location":"specs/Spec_Verlet/#Example","page":"Top-level (Verlet)","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Verlet/","page":"Top-level (Verlet)","title":"Top-level (Verlet)","text":"using Verlet, StaticArrays\nbox = CubicBox(10.0)\nR = [@SVector randn(3) for _ in 1:64]; wrap_positions!(R, box)\nsys = System(R, fill(@SVector zeros(3), 64), fill(@SVector zeros(3), 64), ones(64), box, ones(Int,64), Dict(1=>:A))\nKE = kinetic_energy(sys)","category":"page"},{"location":"specs/Spec_Core/#Spec:-Module-Verlet.Core","page":"Core","title":"Spec: Module Verlet.Core","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"Purpose: Core particle system types, math utilities, simple integrators, and force orchestration.","category":"page"},{"location":"specs/Spec_Core/#Constants","page":"Core","title":"Constants","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"T_Float = Float64: Default floating type for numeric fields.\nT_Int = Int64: Default integer type for indices/types.\nDims = 3: Default spatial dimensionality.","category":"page"},{"location":"specs/Spec_Core/#Boxes","page":"Core","title":"Boxes","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"abstract type AbstractBox{T<:AbstractFloat}: Base for boundary conditions.\nstruct CubicBox{T<:AbstractFloat} <: AbstractBox{T}\nFields: L::T (box side length).\nbox_length(box::CubicBox) -> T\nminimum_image(Δ::AbstractVector, box::CubicBox) and minimum_image(Δ, L)\nWrap displacement to (−L/2, L/2] componentwise.\nwrap_positions!(R::Vector{SVector{Dims,T}}, box::CubicBox{T})\nIn-place wrap of positions to primary cell using minimum image.","category":"page"},{"location":"specs/Spec_Core/#System-and-Particles","page":"Core","title":"System and Particles","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"struct System{T<:AbstractFloat,IT<:Integer,Dims}\nFields:\npositions::Vector{SVector{Dims,T}}\nvelocities::Vector{SVector{Dims,T}}\nforces::Vector{SVector{Dims,T}}\nmasses::Vector{T}\nbox::AbstractBox{T}\ntypes::Vector{IT}\ntype_names::Dict{IT,Symbol}\nnatoms::IT (derived at construction)\nspecific_potentials::Tuple (bonded interactions)\nInvariants:\nAll particle arrays have equal length natoms.\npositions[i], velocities[i], forces[i] are length-Dims SVectors.\nnatoms(sys::System) -> Integer\nnatomtypes(sys::System) -> Int\nkinetic_energy(sys::System{T}) -> T","category":"page"},{"location":"specs/Spec_Core/#Abstract-Potential-Tags","page":"Core","title":"Abstract Potential Tags","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"AbstractPotentialPair, AbstractPairPotential, AbstractBondPotential, AbstractAnglePotential, AbstractDihedralPotential, AbstractImproperPotential.\nMarker types used by potentials for dispatch; no fields or behavior here.","category":"page"},{"location":"specs/Spec_Core/#Neighbor-Types-(tags)","page":"Core","title":"Neighbor Types (tags)","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"abstract type AbstractNeighborList end\nConcrete neighbor structures live in Neighbors and are used by Core APIs via dispatch.","category":"page"},{"location":"specs/Spec_Core/#Forces-and-ForceField","page":"Core","title":"Forces and ForceField","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"struct ForceField{ForcesTuple}\nlayers::ForcesTuple where each layer is a concrete potential (e.g., LennardJones, Coulomb).\nGeneric multimethod hooks:\ncompute_forces!(pot, sys::System) must be implemented by each potential.\ncompute_all_forces!(sys::System, ff::ForceField)\nResets sys.forces to zero element and accumulates contributions from each layer in ff.layers, followed by bonded sys.specific_potentials.\nRequires per-layer neighbor lists to be prepared beforehand (e.g., via Neighbors.build_all_neighbors!).","category":"page"},{"location":"specs/Spec_Core/#Integrators","page":"Core","title":"Integrators","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"velocity_verlet!(system::System{T}, forces::Function, dt::T)\nTwo half kicks with a position drift; evaluates forces(R) twice.\nforces(::Vector{SVector}) must return force vectors matching positions.\npotential_energy(system::System{T}, forces::Function) -> T\nExpects forces(R; return_potential=true) => (F, U); errors if unsupported.","category":"page"},{"location":"specs/Spec_Core/#Performance-and-Complexity","page":"Core","title":"Performance & Complexity","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"All per-particle loops are O(N). Force complexity depends on neighbor list size and potential implementations.\nwrap_positions! and minimum_image are allocation-free for SVector inputs.","category":"page"},{"location":"specs/Spec_Core/#Error-Handling","page":"Core","title":"Error Handling","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"System constructor asserts matching array sizes.\npotential_energy throws if forces does not accept the return_potential=true keyword.","category":"page"},{"location":"specs/Spec_Core/#Example","page":"Core","title":"Example","text":"","category":"section"},{"location":"specs/Spec_Core/","page":"Core","title":"Core","text":"using Verlet.Core, StaticArrays\nbox = CubicBox(10.0)\nR = [@SVector randn(3) for _ in 1:4]; wrap_positions!(R, box)\nsys = System(R, fill(@SVector zeros(3), 4), fill(@SVector zeros(3), 4), ones(4), box, ones(Int,4), Dict(1=>:A))\nvelocity_verlet!(sys, R -> [ -r for r in R ], 0.001)","category":"page"},{"location":"guide/numerics/#NVT-(Langevin-BAOAB)-Thermostat","page":"Numerical Notes","title":"NVT (Langevin BAOAB) Thermostat","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"This guide shows how to run constant-temperature (NVT) dynamics using the Langevin BAOAB integrator and how to monitor/adjust the system temperature with a few convenience tools.","category":"page"},{"location":"guide/numerics/#Why-BAOAB?","page":"Numerical Notes","title":"Why BAOAB?","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Excellent configurational sampling compared to naive Euler–Maruyama.\nRobust for larger dt at a given target T.\nExact Ornstein–Uhlenbeck (OU) substep and only one force evaluation per step.\nWith γ = 0, BAOAB reduces to velocity–Verlet.","category":"page"},{"location":"guide/numerics/#Quick-Start","page":"Numerical Notes","title":"Quick Start","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"# Typical workflow (package API names shown; adapt to your module's name/exports)\nusing Random, StaticArrays\n\nN, D = 64, 3\npositions = [@SVector zeros(D) for _ in 1:N]\nvelocities = [@SVector randn(D) for _ in 1:N]\nmasses = ones(N)\nps = Verlet.Core.System(positions, velocities, masses)\nforces(R) = [ -0.2 .* r for r in R ]  # any user-defined force function\ndt = 0.005      # time step\nγ  = 1.0        # friction [1/time]\nTt = 1.5        # target T  (kB=1.0 here, so T is in energy units)\nrng = MersenneTwister(2025)\n\n# Optional: bring KE near the target quickly\nVerlet.Thermostats.velocity_rescale!(ps, Tt; kB=1.0)\n# Run several steps under NVT\nfor _ in 1:2_000\n\tVerlet.Thermostats.langevin_baoab!(ps, forces, dt; γ=γ, T=Tt, kB=1.0, rng=rng)\nend\n\n@info \"Instantaneous T\" Verlet.Thermostats.instantaneous_temperature(ps; kB=1.0)","category":"page"},{"location":"guide/numerics/#Choosing-γ-and-dt","page":"Numerical Notes","title":"Choosing γ and dt +","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Units: ensure γ is in 1/time and kB*T in energy, consistent with r, v, and m.\nStart with γ*dt ≈ 0.1–1. Larger values overdamp dynamics (OK for sampling; poor for kinetics).\nKeep dt similar to your velocity–Verlet choice at the same force field. BAOAB is often at least as stable. +","category":"page"},{"location":"guide/numerics/#Algorithm-Sketch","page":"Numerical Notes","title":"Algorithm Sketch +","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"BAOAB splits each step into B (half kick) → A (half drift) → O (OU) → A → B. The OU substep uses the exact update v ← c*v + s*ξ with c = exp(-γ*dt) and s = √((1 - c^2) * kB*T / m). See the function docstring for further details, including numerics for small γ*dt. +","category":"page"},{"location":"guide/numerics/#Diagnostics","page":"Numerical Notes","title":"Diagnostics +","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Verlet.Thermostats.instantaneous_temperature(ps; kB) returns the current kinetic temperature using equipartition (dof = N*D for now).\nTime-average Verlet.Thermostats.instantaneous_temperature over many steps (or save to disk) to validate the thermostat. +","category":"page"},{"location":"guide/numerics/#Pitfalls-and-Tips","page":"Numerical Notes","title":"Pitfalls & Tips +","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"Mass heterogeneity: compute OU noise per particle using its mass; do not reuse a single scale across species.\nSmall systems: temperature fluctuates strongly; judge convergence statistically.\nReproducibility: always pass an explicit RNG into Verlet.Thermostats.langevin_baoab!.\nNot a thermostat: Verlet.Thermostats.velocity_rescale! is useful for a single \"KE nudge\" but does not produce the correct canonical distribution. +","category":"page"},{"location":"guide/numerics/#API-Reference","page":"Numerical Notes","title":"API Reference","text":"","category":"section"},{"location":"guide/numerics/","page":"Numerical Notes","title":"Numerical Notes","text":"@docs Verlet.Thermostats.langevin_baoab! Verlet.Thermostats.instantaneous_temperature Verlet.Thermostats.degrees_of_freedom Verlet.Thermostats.velocity_rescale!","category":"page"},{"location":"guide/forces/#Forces-and-Potentials","page":"Forces & Potentials","title":"Forces & Potentials","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"This page describes how to define and use forces in your simulations.","category":"page"},{"location":"guide/forces/#The-ForceField-API","page":"Forces & Potentials","title":"The ForceField API","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"The recommended way to define forces is using the ForceField API. This API allows you to compose multiple potentials (e.g., Lennard-Jones and Coulomb) in a flexible and efficient way.","category":"page"},{"location":"guide/forces/#Example:-Lennard-Jones","page":"Forces & Potentials","title":"Example: Lennard-Jones","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"Here's how to set up a simple Lennard-Jones simulation:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"using Verlet, StaticArrays, LinearAlgebra\n\n# 1. Set up the system\nbox = CubicBox(10.0)\nR = [@SVector(randn(3)) for _ in 1:64]; wrap_positions!(R, box)\nsys = System(\n    R,\n    [@SVector(zeros(3)) for _ in R],\n    [@SVector(zeros(3)) for _ in R],\n    ones(length(R)),\n    box,\n    ones(Int, length(R)),\n    Dict(1 => :A)\n)\n\n# 2. Define the potential\nϵ = 1.0\nσ = 1.0\nrc = 2.5\nlj_pair = LJPair(ϵ, σ, rc)\nparams = PairTable(fill(lj_pair, (1, 1)))\nexclusions = Tuple{T_Int,T_Int}[]\nlj = LennardJones(params, exclusions, 0.5)\n\n# 3. Create a ForceField\nff = Verlet.Neighbors.ForceField((lj,))\n\n# 4. Build neighbor lists and compute forces\nmaster_skin = 0.5\nmaster_nl = Verlet.Neighbors.MasterNeighborList(master_skin)\nVerlet.Neighbors.build_all_neighbors!(master_nl, ff, sys)\nVerlet.Neighbors.compute_all_forces!(sys, ff)\n\n# The forces are now stored in sys.forces\nprintln(sys.forces[1])","category":"page"},{"location":"guide/forces/#Composing-Potentials","page":"Forces & Potentials","title":"Composing Potentials","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"You can easily combine multiple potentials by adding them to the ForceField tuple:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"# lj = LennardJones(...)\n# coul = Coulomb(...)\n# ff = ForceField((lj, coul))","category":"page"},{"location":"guide/forces/#Neighbor-List-Methods","page":"Forces & Potentials","title":"Neighbor List Methods","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"The build_all_neighbors! function uses a master neighbor list to accelerate force calculations. You can choose the method for building this list with the method keyword argument:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"method=:cells (default): Uses a fast, O(N) cell-list algorithm. This is recommended for most systems.\nmethod=:bruteforce: Uses a simple, O(N^2) algorithm. This can be useful for small systems or for debugging.\nmethod=:all_pairs: Includes all pairs of particles, ignoring the cutoff. This is useful for testing or for potentials without a cutoff.","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"Here's how to use it:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"# master_nl = MasterNeighborList(master_skin)\n# build_all_neighbors!(master_nl, ff, sys, method=:bruteforce)","category":"page"},{"location":"guide/forces/#Custom-Forces","page":"Forces & Potentials","title":"Custom Forces","text":"","category":"section"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"You can also define custom force functions. To make potential_energy work, your function should return (F, U) when the keyword return_potential=true is provided:","category":"page"},{"location":"guide/forces/","page":"Forces & Potentials","title":"Forces & Potentials","text":"using Verlet, StaticArrays, LinearAlgebra\nfunction ho_forces(R; return_potential=false)\n    F = [ -r for r in R ]      # k = 1\n    U = 0.5 * sum(norm(r)^2 for r in R)\n    return return_potential ? (F, U) : F\nend\npositions = [@SVector [1.0, 0.0, 0.0]]\nvelocities = [@SVector [0.0, 0.0, 0.0]]\nforces = [@SVector [0.0, 0.0, 0.0]]\nmasses = [1.0]\nbox = CubicBox(10.0)\ntypes = [1]\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names)\n# The potential_energy function needs to be updated to work with the new API\n# For now, I will just call the function\nho_forces(sys.positions)","category":"page"},{"location":"guide/bonded/#Bonded-Potentials","page":"Bonded Potentials","title":"Bonded Potentials","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"Verlet.jl supports a variety of bonded interactions, which are forces that apply to specific groups of atoms (e.g., bonds, angles, dihedrals). These are specified by passing a tuple of interaction objects to the System constructor via the specific_potentials keyword argument.","category":"page"},{"location":"guide/bonded/#Available-Potentials","page":"Bonded Potentials","title":"Available Potentials","text":"","category":"section"},{"location":"guide/bonded/#Harmonic-Bond","page":"Bonded Potentials","title":"Harmonic Bond","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"The harmonic bond potential is given by:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"U(r) = frac12 k (r - r_0)^2","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"It is defined in Verlet.jl as HarmonicBond(k, r0). To apply this potential to a pair of atoms, you create a Bond object:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"bond_potential = HarmonicBond(1000.0, 0.15) # k in kJ/mol/nm^2, r0 in nm\nbond = Bond(1, 2, bond_potential) # Applies to atoms 1 and 2","category":"page"},{"location":"guide/bonded/#Harmonic-Angle","page":"Bonded Potentials","title":"Harmonic Angle","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"The harmonic angle potential is given by:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"U(theta) = frac12 k (theta - theta_0)^2","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"It is defined as HarmonicAngle(k, θ0). To apply it to a triplet of atoms, you create an Angle object:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"angle_potential = HarmonicAngle(100.0, deg2rad(109.5)) # k in kJ/mol/rad^2, θ0 in radians\nangle = Angle(1, 2, 3, angle_potential) # Applies to atoms 1-2-3 (2 is central)","category":"page"},{"location":"guide/bonded/#Periodic-Dihedral","page":"Bonded Potentials","title":"Periodic Dihedral","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"The periodic dihedral (or torsion) potential is given by:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"U(phi) = k (1 + cos(nphi - phi_0))","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"It is defined as PeriodicDihedral(k, n, ϕ0). To apply it to a quadruplet of atoms, you create a Dihedral object:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"dihedral_potential = PeriodicDihedral(10.0, 3, 0.0) # k in kJ/mol, n is integer, ϕ0 in radians\ndihedral = Dihedral(1, 2, 3, 4, dihedral_potential)","category":"page"},{"location":"guide/bonded/#Example-Usage","page":"Bonded Potentials","title":"Example Usage","text":"","category":"section"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"To use these in a simulation, group them into a tuple and pass them to the System:","category":"page"},{"location":"guide/bonded/","page":"Bonded Potentials","title":"Bonded Potentials","text":"bond1 = Bond(1, 2, HarmonicBond(1000.0, 0.15))\nangle1 = Angle(1, 2, 3, HarmonicAngle(100.0, deg2rad(109.5)))\n\nspecific_interactions = (bond1, angle1)\n\nsys = System(\n    ...,\n    specific_potentials=specific_interactions\n)","category":"page"},{"location":"#Verlet.jl","page":"Home","title":"Verlet.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A minimal velocity Verlet integrator for tiny MD-style problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nYou choose the units; just keep them consistent across positions r, velocities v, masses m, forces F, and timestep dt.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Verlet, StaticArrays\n\n# 1. Set up the system\npositions = [@SVector [0.0, 0.0, 0.0]]\nvelocities = [@SVector [1.0, 0.0, 0.0]]\nforces_storage = [@SVector [0.0, 0.0, 0.0]]\nmasses = [1.0]\nbox = CubicBox(10.0)\ntypes = [1]\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces_storage, masses, box, types, type_names)\n\n# 2. Define a potential (e.g., Lennard-Jones)\n# Note: For a single particle, the force will be zero. This is just for demonstration.\nϵ = 1.0\nσ = 1.0\nrc = 2.5\nlj_pair = Verlet.Potentials.LJPair(ϵ, σ, rc)\nparams = Verlet.Potentials.PairTable(fill(lj_pair, (1, 1)))\nexclusions = Tuple{Verlet.Core.T_Int,Verlet.Core.T_Int}[]\nlj = Verlet.Potentials.LennardJones(params, exclusions, 0.5)\nff = Verlet.Neighbors.ForceField((lj,))\n\n# 3. Define a force function compatible with the integrator\nfunction compute_forces_for_integrator(positions, system, forcefield, master_nl)\n    system.positions .= positions # Update positions in the system object\n    Verlet.Neighbors.build_all_neighbors!(master_nl, forcefield, system)\n    Verlet.Neighbors.compute_all_forces!(system, forcefield)\n    return system.forces\nend\n\n# 4. Run the simulation\ndt = 0.1\nmaster_nl = Verlet.Neighbors.MasterNeighborList(0.5)\n# Wrap the force function to match the integrator's signature\nforce_wrapper(R) = compute_forces_for_integrator(R, sys, ff, master_nl)\nVerlet.Core.velocity_verlet!(sys, force_wrapper, dt)\nsys.positions","category":"page"},{"location":"#Harmonic-oscillator","page":"Home","title":"Harmonic oscillator","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Verlet, StaticArrays, LinearAlgebra\n\n# Hooke's law with k = 1, potential U = 0.5 * |r|^2\nfunction ho_forces(R; return_potential=false)\n    F = [-r for r in R]\n    U = 0.5 * sum(norm(r)^2 for r in R)\n    return return_potential ? (F, U) : F\nend\n\npositions = [@SVector [1.0, 0.0, 0.0]]\nvelocities = [@SVector [0.0, 0.0, 0.0]]\nforces = [@SVector [0.0, 0.0, 0.0]]\nmasses = [1.0]\nbox = CubicBox(10.0)\ntypes = [1]\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names)\n\ndt = 0.1\nfor _ in 1:100\n    velocity_verlet!(sys, ho_forces, dt)\nend\n\n(pot = ho_forces(sys.positions, return_potential=true)[2])","category":"page"},{"location":"#Energy-monitoring","page":"Home","title":"Energy monitoring","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Verlet, StaticArrays, LinearAlgebra\n\nfunction ho_forces(R; return_potential=false)\n    F = [-r for r in R]\n    U = 0.5 * sum(norm(r)^2 for r in R)\n    return return_potential ? (F, U) : F\nend\n\npositions = [@SVector [1.0, 0.0, 0.0]]\nvelocities = [@SVector [0.0, 1.0, 0.0]]\nforces = [@SVector [0.0, 0.0, 0.0]]\nmasses = [1.0]\nbox = CubicBox(10.0)\ntypes = [1]\ntype_names = Dict(1 => :A)\nsys = System(positions, velocities, forces, masses, box, types, type_names)\ndt = 0.05\n\nenergies = Float64[]\nfor _ in 1:200\n    velocity_verlet!(sys, ho_forces, dt)\n    push!(energies, ho_forces(sys.positions, return_potential=true)[2]) # kinetic_energy removed\nend\n\n(round(minimum(energies), digits=6), round(maximum(energies), digits=6))","category":"page"},{"location":"#ForceField-API-for-Potentials","page":"Home","title":"ForceField API for Potentials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The recommended way to handle pair potentials like Lennard-Jones is with the ForceField API. This provides a flexible way to combine multiple potentials and uses an efficient neighbor list implementation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Verlet, StaticArrays\n\n# 1. Set up a system\nbox = CubicBox(20.0)\nR = [@SVector randn(3) for _ in 1:100]\nwrap_positions!(R, box)\nsys = System(\n    R,\n    [@SVector(zeros(3)) for _ in R],\n    [@SVector(zeros(3)) for _ in R],\n    ones(length(R)),\n    box,\n    ones(Int, length(R)),\n    Dict(1 => :A)\n)\n\n# 2. Define a Lennard-Jones potential\nlj = Verlet.Potentials.LennardJones(\n    Verlet.Potentials.PairTable(fill(Verlet.Potentials.LJPair(1.0, 1.0, 2.5), (1, 1))),\n    Tuple{Verlet.Core.T_Int,Verlet.Core.T_Int}[],\n    0.5\n)\n\n# 3. Create a ForceField\nff = Verlet.Neighbors.ForceField((lj,))\n\n# 4. Build neighbor lists and compute forces\nmaster_skin = 0.5\nmaster_nl = Verlet.Neighbors.MasterNeighborList(master_skin)\nVerlet.Neighbors.build_all_neighbors!(master_nl, ff, sys)\nVerlet.Neighbors.compute_all_forces!(sys, ff)\n\n@show sys.forces[1]","category":"page"},{"location":"#Neighbor-List-Methods","page":"Home","title":"Neighbor List Methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can choose the neighbor list algorithm with the method keyword in build_all_neighbors!:","category":"page"},{"location":"","page":"Home","title":"Home","text":":cells (default): Fast O(N) cell-based algorithm.\n:bruteforce: Slower O(N^2) algorithm for debugging.\n:all_pairs: Includes all pairs, ignoring cutoffs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"master_nl = Verlet.Neighbors.MasterNeighborList(master_skin)\nVerlet.Neighbors.build_all_neighbors!(master_nl, ff, sys, method=:bruteforce)","category":"page"},{"location":"","page":"Home","title":"Home","text":"build_master_neighborlist! — construct a new master neighbor list.\nwrap_positions! — enforce periodic wrapping of coordinates.","category":"page"},{"location":"#Wrap-the-force-function-to-match-the-integrator's-signature","page":"Home","title":"Wrap the force function to match the integrator's signature","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"forcewrapper(R) = computeforcesforintegrator(R, sys, ff) velocityverlet!(sys, forcewrapper, dt) sys.positions","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Next Steps\n\nCheck out the \\[Guide → Constrained Dynamics](@ref constraints-guide) section to learn how to:\n\n- Set up bond constraints with [`DistanceConstraints`](@ref)\n- Run constrained dynamics with [`velocity_verlet_shake_rattle!`](@ref)\n\n\n## Harmonic oscillator\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@example ho using Verlet, StaticArrays, LinearAlgebra","category":"page"},{"location":"#Hooke's-law-with-k-1,-potential-U-0.5-*-r2","page":"Home","title":"Hooke's law with k = 1, potential U = 0.5 * |r|^2","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"function hoforces(R; returnpotential=false)     F = [-r for r in R]     U = 0.5 * sum(norm(r)^2 for r in R)     return return_potential ? (F, U) : F end","category":"page"},{"location":"","page":"Home","title":"Home","text":"positions = [@SVector [1.0, 0.0, 0.0]] velocities = [@SVector [0.0, 0.0, 0.0]] forces = [@SVector [0.0, 0.0, 0.0]] masses = [1.0] box = CubicBox(10.0) types = [1] typenames = Dict(1 => :A) sys = System(positions, velocities, forces, masses, box, types, typenames)","category":"page"},{"location":"","page":"Home","title":"Home","text":"dt = 0.1 for _ in 1:100     velocityverlet!(sys, hoforces, dt) end","category":"page"},{"location":"","page":"Home","title":"Home","text":"(pot = hoforces(sys.positions, returnpotential=true)[2])","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Energy monitoring\n\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@example energy using Verlet, StaticArrays, LinearAlgebra","category":"page"},{"location":"","page":"Home","title":"Home","text":"function hoforces(R; returnpotential=false)     F = [-r for r in R]     U = 0.5 * sum(norm(r)^2 for r in R)     return return_potential ? (F, U) : F end","category":"page"},{"location":"","page":"Home","title":"Home","text":"positions = [@SVector [1.0, 0.0, 0.0]] velocities = [@SVector [0.0, 1.0, 0.0]] forces = [@SVector [0.0, 0.0, 0.0]] masses = [1.0] box = CubicBox(10.0) types = [1] typenames = Dict(1 => :A) sys = System(positions, velocities, forces, masses, box, types, typenames) dt = 0.05","category":"page"},{"location":"","page":"Home","title":"Home","text":"energies = Float64[] for _ in 1:200     velocityverlet!(sys, hoforces, dt)     push!(energies, hoforces(sys.positions, returnpotential=true)[2]) # kinetic_energy removed end","category":"page"},{"location":"","page":"Home","title":"Home","text":"(round(minimum(energies), digits=6), round(maximum(energies), digits=6))","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n\n## ForceField API for Potentials\n\nThe recommended way to handle pair potentials like Lennard-Jones is with the `ForceField` API. This provides a flexible way to combine multiple potentials and uses an efficient neighbor list implementation.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@example using Verlet, StaticArrays","category":"page"},{"location":"#1.-Set-up-a-system","page":"Home","title":"1. Set up a system","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"box = CubicBox(20.0) R = [@SVector randn(3) for _ in 1:100] wrap_positions!(R, box) sys = System(     R,     [@SVector(zeros(3)) for _ in R],     [@SVector(zeros(3)) for _ in R],     ones(length(R)),     box,     ones(Int, length(R)),     Dict(1 => :A) )","category":"page"},{"location":"#2.-Define-a-Lennard-Jones-potential","page":"Home","title":"2. Define a Lennard-Jones potential","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"lj = LennardJones(     PairTable(fill(LJPair(1.0, 1.0, 2.5), (1, 1))),     Tuple{TInt,TInt}[],     0.5 )","category":"page"},{"location":"#3.-Create-a-ForceField","page":"Home","title":"3. Create a ForceField","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ff = ForceField((lj,))","category":"page"},{"location":"#4.-Build-neighbor-lists-and-compute-forces","page":"Home","title":"4. Build neighbor lists and compute forces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"masterskin = 0.5 buildallneighbors!(ff, sys, masterskin) computeallforces!(sys, ff)","category":"page"},{"location":"","page":"Home","title":"Home","text":"@show sys.forces[1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Neighbor List Methods\n\nYou can choose the neighbor list algorithm with the `method` keyword in `build_all_neighbors!`:\n- `:cells` (default): Fast `O(N)` cell-based algorithm.\n- `:bruteforce`: Slower `O(N^2)` algorithm for debugging.\n- `:all_pairs`: Includes all pairs, ignoring cutoffs.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia buildallneighbors!(ff, sys, master_skin, method=:bruteforce)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n- [`build_master_neighborlist`](@ref) — construct a new master neighbor list.\n- [`wrap_positions!`](@ref) — enforce periodic wrapping of coordinates.\n\n## Further Notes\n\n* [Constraints](@ref) — how SHAKE/RATTLE are applied and how to monitor residuals\n* [Numerical Notes](@ref) — guidance on tolerances, thermostat interaction, and reproducibility\n\n---\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@contents Pages = [\"constraints.md\", \"numerics.md\", \"api.md\"] Depth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"@index Pages = [\"api.md\"] ```","category":"page"},{"location":"specs/Spec_Electrostatics/#Spec:-Module-Verlet.Electrostatics","page":"Electrostatics","title":"Spec: Module Verlet.Electrostatics","text":"","category":"section"},{"location":"specs/Spec_Electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"Purpose: Placeholder for long-range electrostatics algorithms (Ewald/PME/Wolf).","category":"page"},{"location":"specs/Spec_Electrostatics/#Status","page":"Electrostatics","title":"Status","text":"","category":"section"},{"location":"specs/Spec_Electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"Module exists and includes ewald.jl, which currently serves as a scaffold.\nNo public API is exported yet; future work may add parameter types and force kernels integrated with Neighbors and Core.ForceField.","category":"page"},{"location":"specs/Spec_Electrostatics/#Planned-APIs-(non-binding)","page":"Electrostatics","title":"Planned APIs (non-binding)","text":"","category":"section"},{"location":"specs/Spec_Electrostatics/","page":"Electrostatics","title":"Electrostatics","text":"EwaldReal, EwaldReciprocal parameter types and a composite EwaldSum potential.\nPME FFT-based reciprocal-space evaluator hooks.\nCompatibility with PairTable/type-pair parameterization.","category":"page"}]
}
