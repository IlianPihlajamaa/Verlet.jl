```diff
*** Begin Patch
*** Update File: src/Verlet.jl
 module Verlet
 
-export ParticleSystem, velocity_verlet!, kinetic_energy, potential_energy
+export ParticleSystem, velocity_verlet!, kinetic_energy, potential_energy
 
 """
     ParticleSystem
 
 Represents a collection of particles, their positions, velocities, and masses.
 
 Fields:
 - `positions::Matrix{Float64}`: (N × D) array of positions
 - `velocities::Matrix{Float64}`: (N × D) array of velocities
 - `masses::Vector{Float64}`: length-N vector of masses
 """
 mutable struct ParticleSystem
     positions::Matrix{Float64}   # (N × D)
     velocities::Matrix{Float64}  # (N × D)
     masses::Vector{Float64}      # (N)
 end
 
 """
     velocity_verlet!(system::ParticleSystem, forces::Function, dt::Float64)
 
 Advance the system one step using the velocity Verlet integrator.
 
-The `forces` function must accept a positions matrix `(N × D)` and return
-an equally-sized matrix of forces.
+The `forces` function must accept a positions matrix `(N × D)` and **return
+an `(N × D)` matrix of forces**. This function does **not** consume potential
+energy outputs; if potential energy is available, it should be exposed via the
+keyword interface used by [`potential_energy`](@ref).
 """
 function velocity_verlet!(system::ParticleSystem, forces::Function, dt::Float64)
+    @assert size(system.positions) == size(system.velocities) "positions/velocities must be same size"
+    @assert length(system.masses) == size(system.positions, 1) "length(masses) must equal number of particles"
+    dt2 = dt * dt
     # Current accelerations a = F/m, broadcasting over rows (per particle)
     a = forces(system.positions) ./ system.masses
     # Update positions
-    system.positions .+= system.velocities .* dt .+ 0.5 .* a .* (dt^2)
+    system.positions .+= system.velocities .* dt .+ 0.5 .* a .* dt2
     # New accelerations from updated positions
     a_new = forces(system.positions) ./ system.masses
     # Update velocities
     system.velocities .+= 0.5 .* (a .+ a_new) .* dt
     return system
 end
 
 """
     kinetic_energy(system::ParticleSystem) -> Float64
 
 Compute the total kinetic energy `sum(½ m v²)` of the system.
 """
 function kinetic_energy(system::ParticleSystem)::Float64
-    v2_per_particle = sum(abs2, eachrow(system.velocities)) # length N
-    return 0.5 * sum(system.masses .* v2_per_particle)
+    @assert size(system.positions) == size(system.velocities) "positions/velocities must be same size"
+    @assert length(system.masses) == size(system.positions, 1) "length(masses) must equal number of particles"
+    # Sum velocities^2 per particle (row); result is N×1, so vec to N-vector
+    v2 = sum(abs2, system.velocities; dims=2)
+    return 0.5 * sum(system.masses .* vec(v2))
 end
 
 """
     potential_energy(system::ParticleSystem, forces::Function) -> Float64
 
-Attempt to compute total potential energy. This is only possible if the
-`forces` callable supports one of the following conventions:
+Attempt to compute total potential energy. This is only possible if the
+`forces` callable supports the following convention:
 
-1) Returns a tuple `(F, U)` when called with positions, where `F` is the
-   force matrix and `U` is the total potential energy (Float64).
-2) Supports a keyword `return_potential=true` and returns `(F, U)`.
+* Supports a keyword `return_potential=true` and returns `(F, U)` where
+  `F` is the force matrix and `U` is the total potential energy (`Real`).
 
-If neither convention is supported, this function throws an error.
+If this convention is not supported, this function throws an error with a
+clear message.
 """
 function potential_energy(system::ParticleSystem, forces::Function)::Float64
-    # Try convention 1: plain call returns (F, U)
-    F_U = try
-        forces(system.positions)
-    catch
-        nothing
-    end
-    if F_U !== nothing && F_U isa Tuple && length(F_U) == 2
-        _, U = F_U
-        return float(U)
-    end
     # Try convention 2: keyword to request potential
     F_U_kw = try
         forces(system.positions; return_potential=true)
     catch
         nothing
     end
     if F_U_kw !== nothing && F_U_kw isa Tuple && length(F_U_kw) == 2
         _, U = F_U_kw
         return float(U)
     end
-    error("Force function does not provide potential energy; cannot compute potential_energy.")
+    error("Force function does not support `return_potential=true`; cannot compute potential_energy.")
 end
 
 # Keep the original greet to avoid breaking any external references.
 greet() = print("Hello World!")
 
 end # module
*** End Patch
*** Begin Patch
*** Update File: test/runtests.jl
 using Test
 using Verlet
 
 @testset "ParticleSystem construction" begin
     ps = ParticleSystem([0.0 0.0], [1.0 0.0], [1.0])
     @test size(ps.positions) == (1,2)
     @test size(ps.velocities) == (1,2)
     @test ps.masses == [1.0]
 end
 
 @testset "Velocity Verlet free particle" begin
     forces(r) = zeros(size(r))
     ps = ParticleSystem([0.0 0.0], [1.0 0.0], [1.0])
     velocity_verlet!(ps, forces, 0.1)
     @test isapprox(ps.positions[1,1], 0.1; atol=1e-12)
     @test isapprox(ps.velocities[1,1], 1.0; atol=1e-12)
 end
 
 @testset "Velocity Verlet harmonic oscillator" begin
     forces(r) = -r
     ps = ParticleSystem([1.0 0.0], [0.0 0.0], [1.0])
     velocity_verlet!(ps, forces, 0.1)
     @test ps.positions[1,1] < 1.0   # should move left
 end
+
+@testset "kinetic energy" begin
+    # v = (3,4) => v^2 = 25; KE = 0.5 * m * v^2
+    ps = ParticleSystem([0.0 0.0], [3.0 4.0], [2.0])
+    @test isapprox(kinetic_energy(ps), 0.5 * 2.0 * 25.0; atol=1e-12)
+end
+
+@testset "potential energy conventions" begin
+    # A force that supports keyword return_potential
+    function f_kw(r; return_potential::Bool=false)
+        F = -r
+        if return_potential
+            U = 0.5 * sum(r.^2)  # harmonic potential: 0.5 * Σ r^2
+            return (F, U)
+        else
+            return F
+        end
+    end
+    ps = ParticleSystem([1.0 0.0], [0.0 0.0], [1.0])
+    @test isapprox(potential_energy(ps, f_kw), 0.5; atol=1e-12)
+
+    # A force that does NOT provide potential should error
+    f_plain(r) = -r
+    @test_throws ErrorException potential_energy(ps, f_plain)
+end
*** End Patch
```
